FUNCTION  <SNR>147_mapFSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:425
Called 4 times
Total time:   0.002403686
 Self time:   0.000369839

count     total (s)      self (s)
    4   0.002392573   0.000358726     call a:data['sink'](a:t, a:t == 1 ? a:data['f'](a:d) : a:d)

FUNCTION  lsp#get_buffer_first_error_line()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1282
Called 9 times
Total time:   0.023629396
 Self time:   0.000337413

count     total (s)      self (s)
    9   0.023608745   0.000316762     return lsp#internal#diagnostics#first_line#get_first_error_line({'bufnr': bufnr('%')})

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:116
Called 9 times
Total time:   0.005733280
 Self time:   0.000202934

count     total (s)      self (s)
    9   0.005711917   0.000181571   return airline#extensions#ale#get('error')

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:13
Called 9 times
Total time:   0.001151366
 Self time:   0.000202420

count     total (s)      self (s)
    9   0.001134216   0.000185270   return airline#extensions#coc#get('error')

FUNCTION  <SNR>100_get_hunks_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:84
Called 9 times
Total time:   0.000073551
 Self time:   0.000073551

count     total (s)      self (s)
    9                 0.000054400   return ''

FUNCTION  ale#hover#ShowTruncatedMessageAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/hover.vim:350
Called 2 times
Total time:   0.000270472
 Self time:   0.000270472

count     total (s)      self (s)
    2                 0.000027688     let l:buffer = bufnr('')
    2                 0.000040827     let l:pos = getpos('.')[0:2]
                                  
    2                 0.000039101     if !getbufvar(l:buffer, 'ale_enabled', 1)
                                          return
    2                 0.000004013     endif
                                  
    2                 0.000017176     if l:pos != s:last_pos
                                          let s:last_pos = l:pos
                                          let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                                  
                                          if empty(l:loc)
                                              call ale#hover#Show(   l:buffer,   l:pos[1],   l:pos[2],   {'truncated_echo': 1},)
                                          endif
    2                 0.000003475     endif

FUNCTION  <SNR>100_coc_git_enabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:20
Called 9 times
Total time:   0.000344900
 Self time:   0.000344900

count     total (s)      self (s)
    9                 0.000221832   if !exists("*CocAction") || !get(g:, 'airline#extensions#hunks#coc_git', 0)
                                       " coc-git extension is disabled by default
                                       " unless specifically being enabled by the user
                                       " (as requested from coc maintainer)
    9                 0.000048765     return 0
                                    endif
                                    return 1

FUNCTION  <SNR>175_on_stderr()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/client.vim:153
Called 1 time
Total time:   0.000362676
 Self time:   0.000214295

count     total (s)      self (s)
    1                 0.000083753     let l:ctx = get(s:clients, a:id, {})
    1                 0.000019450     if empty(l:ctx)
                                          return
    1                 0.000004738     endif
    1                 0.000016313     if has_key(l:ctx['opts'], 'on_stderr')
    1                 0.000004725         try
    1   0.000189069   0.000040688             call l:ctx['opts']['on_stderr'](a:id, a:data, a:event)
                                          catch
                                              call lsp#log('s:on_stderr exception', v:exception, v:throwpoint)
                                              echom v:exception
    1                 0.000004850         endtry
    1                 0.000001838     endif

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:227
Called 9 times
Total time:   1.074110842
 Self time:   0.024987528

count     total (s)      self (s)
    9                 0.000194681   if !has_key(s:contexts, a:winnr)
                                      return ''
    9                 0.000036288   endif
    9                 0.000167518   let context = s:contexts[a:winnr]
                                  
    9                 0.000156429   if get(w:, 'airline_active', 1)
    9                 0.002805564     let m = mode(1)
                                      " Refer :help mode() to see the list of modes
                                      "   NB: 'let mode' here refers to the display colour _groups_,
                                      "   not the literal mode's code (i.e., m). E.g., Select modes
                                      "   v, S and ^V use 'visual' since they are of similar ilk.
                                      "   Some modes do not get recognised for status line purposes:
                                      "   no, nov, noV, no^V, !, cv, and ce.
                                      "   Mode name displayed is handled in init.vim (g:airline_mode_map).
                                      "
    9                 0.000779854     if m[0] ==# "i"
                                        let mode = ['insert']  " Insert modes + submodes (i, ic, ix)
    9                 0.000234208     elseif m[0] == "R"
                                        let mode = ['replace']  " Replace modes + submodes (R, Rc, Rv, Rx) (NB: case sensitive as 'r' is a mode)
    9                 0.002066850     elseif m[0] =~ '\v(v|V||s|S|)'
                                          let mode = ['visual']  " Visual and Select modes (v, V, ^V, s, S, ^S))
    9                 0.000081841     elseif m ==# "t"
                                        let mode = ['terminal']  " Terminal mode (only has one mode (t))
    9                 0.000248120     elseif m[0] =~ '\v(c|r|!)'
    3                 0.001118740       let mode = ['commandline']  " c, cv, ce, r, rm, r? (NB: cv and ce stay showing as mode entered from)
    6                 0.000024800     else
    6                 0.000075391       let mode = ['normal']  " Normal mode + submodes (n, niI, niR, niV; plus operator pendings no, nov, noV, no^V)
    9                 0.000035027     endif
    9                 0.000280124     if exists("*VMInfos") && !empty(VMInfos())
                                        " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                        let m = 'multi'
    9                 0.000028376     endif
                                      " Adjust to handle additional modes, which don't display correctly otherwise
    9                 0.000303975     if index(['niI', 'niR', 'niV', 'ic', 'ix', 'Rc', 'Rv', 'Rx', 'multi'], m) == -1
    9                 0.000177145       let m = m[0]
    9                 0.000038937     endif
    9                 0.000194433     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                                    else
                                      let mode = ['inactive']
                                      let w:airline_current_mode = get(g:airline_mode_map, '__')
    9                 0.000031600   endif
                                  
    9                 0.000150093   if g:airline_detect_modified && &modified
                                      call add(mode, 'modified')
    9                 0.000031076   endif
                                  
    9                 0.000126167   if g:airline_detect_paste && &paste
                                      call add(mode, 'paste')
    9                 0.000031827   endif
                                  
    9                 0.000182432   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                      call add(mode, 'crypt')
    9                 0.000030852   endif
                                  
    9                 0.000106766   if g:airline_detect_spell && &spell
                                      call add(mode, 'spell')
    9                 0.000030639   endif
                                  
    9                 0.000079191   if &readonly || ! &modifiable
                                      call add(mode, 'readonly')
    9                 0.000031415   endif
                                  
    9                 0.000238186   let mode_string = join(mode)
    9                 0.000173481   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.029972284   0.000260644     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   1.010194618   0.003661343     call airline#highlighter#highlight(mode, string(context.bufnr))
    4   0.013089168   0.000210769     call airline#util#doautocmd('AirlineModeChanged')
    4                 0.000052677     let w:airline_lastmode = mode_string
    9                 0.000022288   endif
                                  
    9                 0.000047001   return ''

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:250
Called 3 times
Total time:   0.007898831
 Self time:   0.000373263

count     total (s)      self (s)
    3                 0.000155619     if exists('*sign_getplaced')
    3   0.007733827   0.000208259         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                      else
                                          let l:line_list = ale#sign#ReadSigns(a:buffer)
                                  
                                          return ale#sign#ParseSigns(l:line_list)
                                      endif

FUNCTION  lsp#get_progress()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1291
Called 9 times
Total time:   0.000324110
 Self time:   0.000219868

count     total (s)      self (s)
    9   0.000303397   0.000199155     return lsp#internal#work_done_progress#get_progress()

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:9
Called 9 times
Total time:   0.016264268
 Self time:   0.000262782

count     total (s)      self (s)
    9   0.016240456   0.000238970   return airline#extensions#coc#get('warning')

FUNCTION  <SNR>208_highlight_range()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:122
Called 40 times
Total time:   0.034898807
 Self time:   0.002963974

count     total (s)      self (s)
                                      " Set all of the positions, which are chunked into Lists which
                                      " are as large as will be accepted by matchaddpos.
   40   0.034622299   0.002687466     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:118
Called 29 times
Total time:   0.018827797
 Self time:   0.006106038

count     total (s)      self (s)
   29                 0.000319373     let l:priority = g:ale#util#style_warning_priority
                                  
                                      " Determine the highest priority item for the line.
   69                 0.000417055     for l:item in a:sublist
   40   0.013491858   0.000770099         let l:item_priority = ale#util#GetItemPriority(l:item)
                                  
   40                 0.000286673         if l:item_priority > l:priority
   29                 0.000344313             let l:priority = l:item_priority
   40                 0.000095967         endif
   69                 0.000290591     endfor
                                  
   29                 0.000206332     if l:priority is# g:ale#util#error_priority
                                          return 'ALEErrorSign'
   29                 0.000057356     endif
                                  
   29                 0.002019409     if l:priority is# g:ale#util#warning_priority
   29                 0.000149955         return 'ALEWarningSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#style_error_priority
                                          return 'ALEStyleErrorSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#style_warning_priority
                                          return 'ALEStyleWarningSign'
                                      endif
                                  
                                      if l:priority is# g:ale#util#info_priority
                                          return 'ALEInfoSign'
                                      endif
                                  
                                      " Use the error sign for invalid severities.
                                      return 'ALEErrorSign'

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 5 times
Total time:   0.020236026
 Self time:   0.009420053

count     total (s)      self (s)
    5                 0.000127479   let curbuf = bufnr('%')
    5                 0.000099041   let curtab = tabpagenr()
    5                 0.000018475   try
    5   0.010962268   0.000146295     call <sid>map_keys()
                                    catch
                                      " no-op
    5                 0.000017888   endtry
    5                 0.000088853   if curbuf == s:current_bufnr && curtab == s:current_tabnr && &columns == s:column_width
    5                 0.008776090     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
    5                 0.000074203       return s:current_tabline
                                      endif
                                    endif
                                  
                                    let b = airline#extensions#tabline#new_builder()
                                    let tab_bufs = tabpagebuflist(tabpagenr())
                                    let show_buf_label_first = 0
                                  
                                    if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                      let show_buf_label_first = 1
                                    endif
                                    if show_buf_label_first
                                      call airline#extensions#tabline#add_label(b, 'buffers', 0)
                                    endif
                                  
                                    let b.tab_bufs = tabpagebuflist(tabpagenr())
                                  
                                    let b.overflow_group = 'airline_tabhid'
                                    let b.buffers = airline#extensions#tabline#buflist#list()
                                    if get(g:, 'airline#extensions#tabline#current_first', 0)
                                      if index(b.buffers, curbuf) > -1
                                        call remove(b.buffers, index(b.buffers, curbuf))
                                      endif
                                      let b.buffers = [curbuf] + b.buffers
                                    endif
                                  
                                    function! b.get_group(i) dict
                                      let bufnum = get(self.buffers, a:i, -1)
                                      if bufnum == -1
                                        return ''
                                      endif
                                      let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                      if bufnum == bufnr('%')
                                        let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                      endif
                                      return group
                                    endfunction
                                  
                                    if has("tablineat")
                                      function! b.get_pretitle(i) dict
                                        let bufnum = get(self.buffers, a:i, -1)
                                        return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                      endfunction
                                  
                                      function! b.get_posttitle(i) dict
                                        return '%X'
                                      endfunction
                                    endif
                                  
                                    function! b.get_title(i) dict
                                      let bufnum = get(self.buffers, a:i, -1)
                                      let group = self.get_group(a:i)
                                      let pgroup = self.get_group(a:i - 1)
                                      " always add a space when powerline_fonts are used
                                      " or for the very first item
                                      if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                        let space = s:spc
                                      else
                                        let space= (pgroup == group ? s:spc : '')
                                      endif
                                  
                                      if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                        if len(s:number_map) > 0
                                          return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                        else
                                          return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                        endif
                                      else
                                        return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                      endif
                                    endfunction
                                  
                                    let current_buffer = max([index(b.buffers, curbuf), 0])
                                    let last_buffer = len(b.buffers) - 1
                                    call b.insert_titles(current_buffer, 0, last_buffer)
                                  
                                    call b.add_section('airline_tabfill', '')
                                    call b.split()
                                    call b.add_section('airline_tabfill', '')
                                    if !show_buf_label_first
                                      call airline#extensions#tabline#add_label(b, 'buffers', 1)
                                    endif
                                  
                                    call airline#extensions#tabline#add_tab_label(b)
                                  
                                    let s:current_bufnr = curbuf
                                    let s:current_tabnr = curtab
                                    let s:column_width = &columns
                                    let s:current_tabline = b.build()
                                    let s:current_visible_buffers = copy(b.buffers)
                                    " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                                    "if b._right_title <= last_buffer
                                    "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                                    "endif
                                    "if b._left_title > 0
                                    "  call remove(s:current_visible_buffers, 0, b._left_title)
                                    "endif
                                    return s:current_tabline

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:34
Called 3 times
Total time:   0.000258972
 Self time:   0.000144180

count     total (s)      self (s)
    3   0.000174557   0.000059765     call ale#command#InitData(a:buffer)
    3                 0.000042826     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:192
Called 9 times
Total time:   0.000794052
 Self time:   0.000281847

count     total (s)      self (s)
    9   0.000772354   0.000260149   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? "\u2026" : '>') : &filetype

FUNCTION  airline#extensions#tabline#formatters#unique_tail#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/unique_tail.vim:6
Called 5 times
Total time:   0.006275874
 Self time:   0.005629452

count     total (s)      self (s)
    5                 0.000065267   let duplicates = {}
    5                 0.000035515   let tails = {}
    5                 0.000041351   let map = {}
   10                 0.000087027   for nr in a:buffers
    5                 0.002157065     let name = bufname(nr)
    5                 0.000064390     if empty(name)
                                        let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, '[No Name]')
    5                 0.000027588     else
    5                 0.000167343       if name =~ 'term://'
                                          " Neovim Terminal
                                          let tail = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
    5                 0.000031801       else
    5                 0.000202881         let tail = fnamemodify(name, ':s?/\+$??:t')
    5                 0.000035787       endif
    5                 0.000059315       if has_key(tails, tail)
                                          let duplicates[nr] = nr
    5                 0.000010724       endif
    5                 0.000062128       let tails[tail] = 1
    5   0.000845718   0.000199296       let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, tail)
    5                 0.000015640     endif
   10                 0.000063324   endfor
                                  
    5                 0.000069189   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':p:.')
    5                 0.000064540   for nr in values(duplicates)
                                      let name = bufname(nr)
                                      let fnamecollapse = get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                      if fnamecollapse
                                        let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g'))
                                      else
                                        let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, fnamemodify(name, fmod))
                                      endif
    5                 0.000014051   endfor
                                  
    5                 0.000059351   if has_key(map, a:bufnr)
    5                 0.000058501     return map[a:bufnr]
                                    endif
                                  
                                    " if we get here, the buffer list isn't in sync with the selected buffer yet, fall back to the default
                                    return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)

FUNCTION  lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:156
Called 18 times
Total time:   0.019462594
 Self time:   0.009066705

count     total (s)      self (s)
   18                 0.000365852     let l:counts = { 'error': 0, 'warning': 0, 'information': 0, 'hint': 0, }
   18   0.000825743   0.000405642     if lsp#internal#diagnostics#state#_is_enabled_for_buffer(a:bufnr)
   18   0.009391935   0.000457777         let l:uri = lsp#utils#get_buffer_uri(a:bufnr)
   36   0.001416850   0.000739461         for [l:_, l:response] in items(lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri))
   90   0.001155706   0.000791465             for l:diagnostic in lsp#utils#iteratable(l:response['params']['diagnostics'])
   72                 0.001687212                 let l:key = get(s:diagnostic_kinds, get(l:diagnostic, 'severity', 1) , 'error')
   72                 0.002971482                 let l:counts[l:key] += 1
   90                 0.000354308             endfor
   36                 0.000091675         endfor
   18                 0.000039113     end
   18                 0.000096914     return l:counts

FUNCTION  <SNR>214_UpdateCacheIfNecessary()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:78
Called 21 times
Total time:   0.012302893
 Self time:   0.000801456

count     total (s)      self (s)
                                      " Cache is cold, so manually ask for an update.
   21                 0.000353164     if !has_key(g:ale_buffer_info[a:buffer], 'count')
    1   0.011548664   0.000047227         call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
   21                 0.000061828     endif

FUNCTION  <SNR>74_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:186
Called 6 times
Total time:   0.016680909
 Self time:   0.016512016

count     total (s)      self (s)
    6   0.000391039   0.000222146   let channel = coc#client#get_channel(self)
    6                 0.000091542   if empty(channel)
                                      return ''
    6                 0.000019375   endif
    6                 0.000025027   try
    6                 0.000039362     if s:is_vim
    6                 0.009298021       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
                                      else
                                        call call('rpcnotify', [channel, a:method] + a:args)
    6                 0.000028414     endif
                                    catch /.*/
                                      if v:exception =~# 'E475'
                                        if get(g:, 'coc_vim_leaving', 0)
                                          return
                                        endif
                                        echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                        let name = self.name
                                        call s:on_exit(name, 0)
                                        execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                      elseif v:exception =~# 'E12'
                                        " neovim's bug, ignore it
                                      else
                                        echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                      endif
    6                 0.000036576   endtry

FUNCTION  <SNR>205_IsHeaderFile()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/gcc.vim:16
Called 12 times
Total time:   0.000675188
 Self time:   0.000675188

count     total (s)      self (s)
   12                 0.000634622     return a:filename =~? '\v\.(h|hpp)$'

FUNCTION  airline#extensions#lsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:34
Called 18 times
Total time:   0.063144319
 Self time:   0.018026943

count     total (s)      self (s)
   18                 0.000456805   if !exists(':LspDeclaration')
                                      return ''
   18                 0.000038838   endif
                                  
   18                 0.000277773   let error_symbol = get(g:, 'airline#extensions#lsp#error_symbol', 'E:')
   18                 0.006329475   let warning_symbol = get(g:, 'airline#extensions#lsp#warning_symbol', 'W:')
   18                 0.000303649   let show_line_numbers = get(g:, 'airline#extensions#lsp#show_line_numbers', 1)
                                  
   18                 0.006767416   let is_err = a:type ==# 'error'
                                  
   18                 0.000211520   let symbol = is_err ? error_symbol : warning_symbol
                                  
   18   0.020603363   0.000405644   let num = lsp#get_buffer_diagnostics_counts()[a:type]
                                  
   18                 0.000127367   if show_line_numbers == 1
   18   0.027712591   0.002792934     return s:airline_lsp_count(num, symbol) . <sid>airline_lsp_get_line_number(num, a:type)
                                    else
                                      return s:airline_lsp_count(num, symbol)
                                    endif

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:307
Called 4 times
Total time:   0.009555666
 Self time:   0.000300873

count     total (s)      self (s)
                                    " airline#visual_active
                                    " Boolean: for when to get visual wordcount
                                    " needed for the wordcount extension
    4                 0.000177607   let g:airline#visual_active = (mode() =~? '[vs]')
    4   0.009340997   0.000086204   call airline#update_tabline()

FUNCTION  <SNR>139_VimExitCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:114
Called 3 times
Total time:   0.412193229
 Self time:   0.000658725

count     total (s)      self (s)
    3   0.000162968   0.000078052     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
    3                 0.000054215     let l:info = get(s:job_map, l:job_id, {})
                                  
    3                 0.000029427     if empty(l:info)
                                          return
    3                 0.000006263     endif
                                  
    3                 0.000036976     let l:info.exit_code = a:exit_code
                                  
                                      " The program can exit before the data has finished being read.
    3                 0.000052314     if ch_status(job_getchannel(a:job)) is# 'closed'
    3                 0.000011939         try
    3                 0.000046264             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                                  " We have to remove the callback, so we don't call it twice.
    3   0.411601157   0.000151569                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
    3                 0.000008312             endif
    3                 0.000008226         finally
                                              " Automatically forget about the job after it's done.
    3                 0.000042238             if has_key(s:job_map, l:job_id)
    3                 0.000049241                 call remove(s:job_map, l:job_id)
    3                 0.000009250             endif
    3                 0.000007500         endtry
    3                 0.000004738     endif

FUNCTION  lsp#internal#work_done_progress#get_progress()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/work_done_progress.vim:68
Called 9 times
Total time:   0.000104242
 Self time:   0.000104242

count     total (s)      self (s)
    9                 0.000077679     return s:progress_ui

FUNCTION  <SNR>101_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:68
Called 14 times
Total time:   0.010688557
 Self time:   0.000608371

count     total (s)      self (s)
                                    " Use the new ALE statusline API function if it is available.
   14                 0.000210343   if exists("*ale#statusline#FirstProblem")
   14   0.010410874   0.000330688     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                                    endif
                                  
                                    return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  coc#api#Eval()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:644
Called 2 times
Total time:   0.002161815
 Self time:   0.000084628

count     total (s)      self (s)
    2   0.002153603   0.000076416   legacy return coc#compat#eval(a:expr)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:178
Called 4 times
Total time:   0.012878399
 Self time:   0.000468742

count     total (s)      self (s)
    4                 0.000084454   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                      " airline disabled
                                      return
    4                 0.000008701   endif
    4                 0.000007762   try
    4   0.012684003   0.000274346     exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)
                                    catch /^Vim\%((\a\+)\)\=:E48:/
                                      " Catch: Sandbox mode
                                      " no-op
    4                 0.000015499   endtry

FUNCTION  ale#virtualtext#CompareSeverityPerLine()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:277
Called 73 times
Total time:   0.014994237
 Self time:   0.007789694

count     total (s)      self (s)
                                      " Compare lines
   73                 0.005784338     if a:left.lnum < a:right.lnum
   61                 0.000309863         return -1
   12                 0.000027201     endif
                                  
   12                 0.000074929     if a:left.lnum > a:right.lnum
                                          return 1
   12                 0.000025001     endif
                                  
   12   0.006975740   0.000385405     let l:left_priority = ale#util#GetItemPriority(a:left)
   12   0.000845556   0.000231348     let l:right_priority = ale#util#GetItemPriority(a:right)
                                  
                                      " Put highest priority items first.
   12                 0.000092078     if l:left_priority > l:right_priority
                                          return -1
   12                 0.000025063     endif
                                  
   12                 0.000071876     if l:left_priority < l:right_priority
                                          return 1
   12                 0.000022800     endif
                                  
                                      " Put the first seen problem first.
   12                 0.000087750     return a:left.col - a:right.col

FUNCTION  coc#util#editor_infos()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:450
Called 2 times
Total time:   0.001580095
 Self time:   0.000703299

count     total (s)      self (s)
    2                 0.000023213   let result = []
    4                 0.000062341   for info in getwininfo()
    2   0.000176706   0.000110515     if !coc#window#is_float(info['winid'])
    2                 0.000019276       let bufnr = info['bufnr']
    2                 0.000050639       let buftype = getbufvar(bufnr, '&buftype')
    2                 0.000018326       if buftype !=# '' && buftype !=# 'acwrite'
                                          continue
    2                 0.000004637       endif
    2   0.000947809   0.000137204       call add(result, { 'winid': info['winid'], 'bufnr': bufnr, 'tabid': coc#compat#tabnr_id(info['tabnr']), 'fullpath': coc#util#get_fullpath(bufnr), })
    2                 0.000006212     endif
    4                 0.000012987   endfor
    2                 0.000010739   return result

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:5
Called 4 times
Total time:   0.000110717
 Self time:   0.000110717

count     total (s)      self (s)
    4                 0.000097778     return call('mode', a:000)

FUNCTION  coc#window#is_float()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/window.vim:73
Called 2 times
Total time:   0.000066191
 Self time:   0.000066191

count     total (s)      self (s)
    2                 0.000018337   if s:is_vim
    2                 0.000039165     return index(popup_list(), a:winid) != -1
                                    else
                                      if nvim_win_is_valid(a:winid)
                                        let config = nvim_win_get_config(a:winid)
                                        return !empty(get(config, 'relative', ''))
                                      endif
                                    endif
                                    return 0

FUNCTION  <SNR>120_ApplyPartialTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:447
Called 3 times
Total time:   0.387528295
 Self time:   0.000636422

count     total (s)      self (s)
    3                 0.000322799     if has_key(s:partial_timers, a:timer_id)
    3                 0.000123879         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    3   0.387041528   0.000149655         call call(l:Callback, [a:timer_id] + l:args)
    3                 0.000007727     endif

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:43
Called 3 times
Total time:   0.000162493
 Self time:   0.000162493

count     total (s)      self (s)
    3                 0.000144831     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  ale#job#ParseVim8ProcessID()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:140
Called 28 times
Total time:   0.001090290
 Self time:   0.001090290

count     total (s)      self (s)
   28                 0.001020013     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:101
Called 24 times
Total time:   0.003556405
 Self time:   0.003556405

count     total (s)      self (s)
   24                 0.000645813     let l:info = get(g:ale_buffer_info, a:buffer, {})
                                  
   24                 0.002767125     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:77
Called 18 times
Total time:   0.046611415
 Self time:   0.017853921

count     total (s)      self (s)
   18                 0.000381776   if !exists(':ALELint')
                                      return ''
   18                 0.000044000   endif
                                  
   18                 0.001391210   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
   18                 0.000301274   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
   18                 0.000253630   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
   18                 0.000277262   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                                  
   18                 0.000168144   let is_err = a:type ==# 'error'
                                  
   18   0.007787776   0.004537295   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
    4                 0.000034703     return is_err ? '' : checking_symbol
   14                 0.000037012   endif
                                  
   14                 0.000134469   let symbol = is_err ? error_symbol : warning_symbol
                                  
   14   0.022867654   0.008243205   let counts = ale#statusline#Count(bufnr(''))
   14                 0.000347963   if type(counts) == type({}) && has_key(counts, 'error')
                                      " Use the current Dictionary format.
   14                 0.000142203     let errors = counts.error + counts.style_error
   14                 0.000140831     let num = is_err ? errors : counts.total - errors
                                    else
                                      " Use the old List format.
                                      let num = is_err ? counts[0] : counts[1]
   14                 0.000035312   endif
                                  
   14                 0.000076905   if show_line_numbers == 1
   14   0.011517761   0.000635197     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                                    else
                                      return s:airline_ale_count(num, symbol)
                                    endif

FUNCTION  <SNR>101_new_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:40
Called 14 times
Total time:   0.010080186
 Self time:   0.002435000

count     total (s)      self (s)
                                    " The FirstProblem call in ALE is a far more efficient way
                                    " of obtaining line number data. If the installed ALE supports
                                    " it, we should use this method of getting line data.
   14                 0.000100228   if a:cnt == 0
    7                 0.000031626     return ''
    7                 0.000019588   endif
    7                 0.000085128   let l:buffer = bufnr('')
                                  
                                    " Try to get the first error from ALE.
    7   0.007812254   0.000167068   let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
    7                 0.000081204   if empty(l:result)
                                      " If there are no errors then try and check for style errors.
                                      let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
    7                 0.000020726   endif
                                  
    7                 0.000053741   if empty(l:result)
                                        return ''
    7                 0.000014238   endif
                                  
    7                 0.000106868   let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
    7                 0.001253444   let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                                  
    7                 0.000167106   return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  <SNR>147_debounceTimeSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:577
Called 4 times
Total time:   0.000419929
 Self time:   0.000419929

count     total (s)      self (s)
    4                 0.000132429     if has_key(a:data, 'timer') | call timer_stop(a:data['timer']) | endif
    4                 0.000021715     if a:t == 1
    4                 0.000195945         let a:data['timer'] = timer_start(a:data['duration'], function('s:debounceTimeTimerCallback', [a:data, a:d]))
                                      else
                                          call a:data['sink'](a:t, a:d)
    4                 0.000010302     endif

FUNCTION  coc#api#TabNrId()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:234
Called 2 times
Total time:   0.000210470
 Self time:   0.000210470

count     total (s)      self (s)
    2                 0.000012838   var tid = gettabvar(nr, '__coc_tid', -1)
    2                 0.000003263   if tid == -1
                                      tid = tab_id
                                      settabvar(nr, '__coc_tid', tid)
                                      tab_id += 1
                                    endif
                                    return tid

FUNCTION  lsp#utils#get_buffer_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:189
Called 27 times
Total time:   0.016266033
 Self time:   0.015413128

count     total (s)      self (s)
   27                 0.010830833     let l:name = a:0 > 0 ? bufname(a:1) : expand('%')
   27                 0.000331161     if empty(l:name)
                                          let l:nr = a:0 > 0 ? a:1 : bufnr('%')
                                          let l:name = printf('%s/__NO_NAME_%d__', getcwd(), l:nr)
   27                 0.000088679     endif
   27   0.003803584   0.002950679     return lsp#utils#path_to_uri(fnamemodify(l:name, ':p'))

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:169
Called 5 times
Total time:   0.022599772
 Self time:   0.002363746

count     total (s)      self (s)
    5                 0.000192756     let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    5                 0.000074365     let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                                  
    5                 0.000068153     let curtabcnt = tabpagenr('$')
    5                 0.000054015     if curtabcnt != s:current_tabcnt
                                        let s:current_tabcnt = curtabcnt
                                        call airline#extensions#tabline#tabs#invalidate()
                                        call airline#extensions#tabline#buffers#invalidate()
                                        call airline#extensions#tabline#ctrlspace#invalidate()
                                        call airline#extensions#tabline#tabws#invalidate()
    5                 0.000016801     endif
                                  
    5                 0.000114017     if !exists('#airline#BufAdd#*')
                                        autocmd airline BufAdd * call <sid>update_tabline(0)
    5                 0.000009426     endif
    5                 0.001070051     if !exists('#airline#SessionLoadPost')
                                        autocmd airline SessionLoadPost * call <sid>update_tabline(1)
    5                 0.000010863     endif
    5                 0.000031651     if s:ctrlspace
                                        return airline#extensions#tabline#ctrlspace#get()
    5                 0.000034026     elseif s:tabws
                                        return airline#extensions#tabline#tabws#get()
    5                 0.000047577     elseif show_buffers && curtabcnt == 1 || !show_tabs
    5   0.020384655   0.000148629       return airline#extensions#tabline#buffers#get()
                                      else
                                        return airline#extensions#tabline#tabs#get()
                                      endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:65
Called 9 times
Total time:   0.019497611
 Self time:   0.018355145

count     total (s)      self (s)
    9                 0.000191095   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    9                 0.000280173   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                      return ''
    9                 0.000021913   endif
    9                 0.000210607   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                                  
    9                 0.000188857   if !exists('b:airline_whitespace_check')
                                      let b:airline_whitespace_check = ''
                                      let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                                  
                                      let trailing = 0
                                      let check = 'trailing'
                                      if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                        try
                                          let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
                                          let trailing = search(regexp, 'nw')
                                        catch
                                          call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                          echomsg v:exception
                                          return ''
                                        endtry
                                      endif
                                  
                                      let mixed = 0
                                      let check = 'indent'
                                      if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                        let mixed = s:check_mixed_indent()
                                      endif
                                  
                                      let mixed_file = ''
                                      let check = 'mixed-indent-file'
                                      if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                        let mixed_file = s:check_mixed_indent_file()
                                      endif
                                  
                                      let long = 0
                                      if index(checks, 'long') > -1 && &tw > 0
                                        let long = search('\%>'.&tw.'v.\+', 'nw')
                                      endif
                                  
                                      let conflicts = 0
                                      if index(checks, 'conflicts') > -1
                                        let conflicts = s:conflict_marker()
                                      endif
                                  
                                      if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                        let b:airline_whitespace_check = s:symbol
                                        if strlen(s:symbol) > 0
                                          let space = (g:airline_symbols.space)
                                        else
                                          let space = ''
                                        endif
                                  
                                        if s:show_message
                                          if trailing != 0
                                            let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                            let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                          endif
                                          if mixed != 0
                                            let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                            let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                          endif
                                          if long != 0
                                            let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                            let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                          endif
                                          if !empty(mixed_file)
                                            let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                            let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                          endif
                                          if conflicts != 0
                                            let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                            let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                          endif
                                        endif
                                      endif
    9                 0.000018211   endif
    9   0.001361164   0.000218698   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>135_GatherOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:281
Called 20 times
Total time:   0.000403563
 Self time:   0.000403563

count     total (s)      self (s)
   20                 0.000336612     call add(a:line_list, a:line)

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:88
Called 9 times
Total time:   0.003557378
 Self time:   0.003138927

count     total (s)      self (s)
    9                 0.000176582   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    9                 0.000111240     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                        let b:source_func = 's:get_hunks_signify'
    9                 0.000138255     elseif exists('*GitGutterGetHunkSummary') && get(g:, 'gitgutter_enabled')
                                        let b:source_func = 's:get_hunks_gitgutter'
    9                 0.000089878     elseif exists('*changes#GetStats')
                                        let b:source_func = 's:get_hunks_changes'
    9                 0.000100880     elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                        let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
    9                 0.001529617     elseif exists(':Gitsigns')
                                        let b:source_func = 's:get_hunks_gitsigns'
    9   0.000589608   0.000244708     elseif s:coc_git_enabled()
                                        let b:source_func = 's:get_hunks_coc'
    9                 0.000021451     else
    9                 0.000073577       let b:source_func = 's:get_hunks_empty'
    9                 0.000022689     endif
    9                 0.000014852   endif
    9   0.000310936   0.000237385   return {b:source_func}()

FUNCTION  ale#virtualtext#SetTexts()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:303
Called 3 times
Total time:   0.105971207
 Self time:   0.004420751

count     total (s)      self (s)
    3                 0.000189144     if !has('nvim') && s:emulate_virt
                                          return
    3                 0.000009099     endif
                                  
    3   0.000828816   0.000097065     call ale#virtualtext#Clear(a:buffer)
                                  
    3                 0.000241610     let l:buffer_list = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
                                  
    3   0.000242820   0.000061263     if ale#Var(a:buffer,'virtualtext_single')
                                          " If we want a single problem per line, sort items on each line by
                                          " highest severity and then lowest column position, then de-duplicate
                                          " the items by line.
    3   0.016084713   0.000993800         call uniq(   sort(l:buffer_list, function('ale#virtualtext#CompareSeverityPerLine')),   {a, b -> a.lnum - b.lnum})
    3                 0.000010850     endif
                                  
   32                 0.000291938     for l:item in l:buffer_list
   29   0.087761026   0.002214791         call ale#virtualtext#ShowMessage(a:buffer, l:item)
   32                 0.000150644     endfor

FUNCTION  <SNR>147_notify_event_handler()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:520
Called 4 times
Total time:   0.010602942
 Self time:   0.007339374

count     total (s)      self (s)
    4                 0.000095191     let l:data = s:event_handlers_data[a:index]
    4   0.010490189   0.007226621     call l:data['handler']()

FUNCTION  airline#extensions#lsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:56
Called 9 times
Total time:   0.023387602
 Self time:   0.000322241

count     total (s)      self (s)
    9   0.023368751   0.000303390   return airline#extensions#lsp#get('warning')

FUNCTION  ale#handlers#gcc#HandleGCCFormat()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/gcc.vim:104
Called 3 times
Total time:   0.048081209
 Self time:   0.028590460

count     total (s)      self (s)
    3                 0.000032788     let l:output = []
                                  
   15   0.022775154   0.006493921     for l:match in ale#util#GetMatches(a:lines, s:pattern)
                                          " Filter out the pragma errors
   12   0.001515982   0.000840794         if s:IsHeaderFile(bufname(bufnr('')))&& l:match[5][:len(s:pragma_error) - 1] is# s:pragma_error
                                              continue
   12                 0.000026464         endif
                                  
                                          " If the 'error type' is a note, make it detail related to
                                          " the previous error parsed in output
   12                 0.000174418         if l:match[4] is# 'note'
    2                 0.000020763             if !empty(l:output)
    2                 0.002506540                 if !has_key(l:output[-1], 'detail')
    2                 0.000215683                     let l:output[-1].detail = l:output[-1].text
                                  
                                                      " handle macro expansion errors/notes
    2                 0.000082952                     if l:match[5] =~? '^in expansion of macro \w*\w$'
                                                          " if the macro expansion is in the file we're in, add
                                                          " the lnum and col keys to the previous error
                                                          if l:match[1] is# '<stdin>' && !has_key(l:output[-1], 'col')
                                                              let l:output[-1].lnum = str2nr(l:match[2])
                                                              let l:output[-1].col = str2nr(l:match[3])
                                                          else
                                                              " the error is not in the current file, and since
                                                              " macro expansion errors don't show the full path to
                                                              " the error from the current file, we have to just
                                                              " give out a generic error message
                                                              let l:output[-1].text = 'Error found in macro expansion. See :ALEDetail'
                                                          endif
    2                 0.000003150                     endif
    2                 0.000003312                 endif
                                  
    2   0.001217606   0.000118229                 let l:output[-1].detail = l:output[-1].detail . "\n"   . s:RemoveUnicodeQuotes(l:match[0])
    2                 0.000011050             endif
                                  
    2                 0.000012487             continue
   10                 0.000019199         endif
                                  
   10   0.002065512   0.000630561         let l:item = {   'lnum': str2nr(l:match[2]),   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',   'text': s:RemoveUnicodeQuotes(l:match[5]),}
                                  
   10                 0.000146081         if !empty(l:match[3])
    6                 0.000144479             let l:item.col = str2nr(l:match[3])
   10                 0.000030254         endif
                                  
                                          " If the filename is something like <stdin>, <nofile> or -, then
                                          " this is an error for the file we checked.
   10                 0.002340922         if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
   10                 0.000168419             let l:item['filename'] = l:match[1]
   10                 0.001848302         endif
                                  
   10                 0.000641147         call add(l:output, l:item)
   13                 0.000076142     endfor
                                  
    3                 0.000030388     return l:output

FUNCTION  <SNR>214_GetCounts()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:97
Called 14 times
Total time:   0.013636725
 Self time:   0.001041570

count     total (s)      self (s)
   14   0.000846508   0.000300437     if !s:BufferCacheExists(a:buffer)
                                          return s:CreateCountDict()
   14                 0.000040989     endif
                                  
   14   0.012368292   0.000319208     call s:UpdateCacheIfNecessary(a:buffer)
                                  
   14                 0.000159881     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>205_RemoveUnicodeQuotes()
    Defined: ~/.vim/plugged/ale/autoload/ale/handlers/gcc.vim:20
Called 12 times
Total time:   0.002534328
 Self time:   0.002534328

count     total (s)      self (s)
   12                 0.000140278     let l:text = a:text
   12                 0.000699199     let l:text = substitute(l:text, '[`]', '''', 'g')
   12                 0.000319059     let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
   12                 0.000783264     let l:text = substitute(l:text, '[]', '"', 'g')
                                  
   12                 0.000512406     return l:text

FUNCTION  coc#compat#eval()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/compat.vim:95
Called 2 times
Total time:   0.002077187
 Self time:   0.000146255

count     total (s)      self (s)
    2   0.002072398   0.000141466   return eval(a:expr)

FUNCTION  <SNR>207_WinFindBuf()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:96
Called 3 times
Total time:   0.000128879
 Self time:   0.000128879

count     total (s)      self (s)
    3                 0.000117716     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>207_SetListsImpl()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:100
Called 3 times
Total time:   0.386891873
 Self time:   0.009023250

count     total (s)      self (s)
    3                 0.000260172     let l:title = expand('#' . a:buffer . ':p')
                                  
    3                 0.000021214     if g:ale_set_quickfix
                                          let l:quickfix_list = ale#list#GetCombinedList()
                                  
                                          if has('nvim')
                                              call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                          else
                                              call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                              call setqflist([], 'r', {'title': l:title})
                                          endif
    3                 0.000015575     elseif g:ale_set_loclist
                                          " If windows support is off, win_findbuf() may not exist.
                                          " We'll set result in the current window, which might not be correct,
                                          " but it's better than nothing.
    3   0.000203146   0.000074267         let l:ids = s:WinFindBuf(a:buffer)
                                  
    3   0.314932397   0.000081579         let l:loclist = s:Deduplicate(a:loclist)
                                  
    6                 0.000048952         for l:id in l:ids
    3                 0.005792032             if has('nvim')
                                                  call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
    3                 0.000013163             else
    3   0.063258602   0.001090115                 call setloclist(l:id, s:FixList(a:buffer, l:loclist))
    3                 0.000096166                 call setloclist(l:id, [], 'r', {'title': l:title})
    3                 0.000010388             endif
    6                 0.000016711         endfor
    3                 0.000006312     endif
                                  
                                      " Save the current view before opening/closing any window
    3                 0.000081904     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                                  
                                      " Open a window to show the problems if we need to.
                                      "
                                      " ShouldOpen() checks if the current buffer has enough problems to be
                                      " opened.
    3   0.000477293   0.000121892     if s:ShouldOpen(a:buffer, len(a:loclist))
                                          let l:winnr = winnr()
                                          let l:mode = mode()
                                  
                                          " open windows vertically instead of default horizontally
                                          let l:open_type = ''
                                  
                                          if ale#Var(a:buffer, 'list_vertical') == 1
                                              let l:open_type = 'vert rightbelow '
                                          endif
                                  
                                          if g:ale_set_quickfix
                                              if !ale#list#IsQuickfixOpen()
                                                  silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                              endif
                                          elseif g:ale_set_loclist
                                              silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                          endif
                                  
                                          " If focus changed, restore it (jump to the last window).
                                          if l:winnr isnot# winnr()
                                              wincmd p
                                          endif
                                  
                                          " Return to original mode when applicable
                                          if mode() != l:mode
                                              if l:mode is? 'v' || l:mode is# "\<c-v>"
                                                  " Reset our last visual selection
                                                  normal! gv
                                              elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                                  " Reset our last character selection
                                                  normal! "\<c-g>"
                                              endif
                                          endif
                                  
                                          call s:RestoreViewIfNeeded(a:buffer)
    3                 0.000009838     endif
                                  
                                      " If ALE isn't currently checking for more problems, close the window if
                                      " needed now. This check happens inside of this timer function, so
                                      " the window can be closed reliably.
    3   0.000190458   0.000043991     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000253759   0.000035188         call s:CloseWindowIfNeeded(a:buffer)
    3                 0.000008812     endif

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:503
Called 5 times
Total time:   0.016222944
 Self time:   0.016025537

count     total (s)      self (s)
    5                 0.000042839   if a:0 == 0
                                      let fileNodeExtension = !empty(expand('%:e')) ? expand('%:e') : &filetype
                                      let fileNode = expand('%:t')
                                      let isDirectory = 0
    5                 0.000011652   else
    5                 0.000061764     let fileNodeExtension = fnamemodify(a:1, ':e')
    5                 0.000070803     let fileNode = fnamemodify(a:1, ':t')
    5                 0.000032351     if a:0 > 1
                                        let isDirectory = a:2
    5                 0.000011277     else
    5                 0.000034599       let isDirectory = 0
    5                 0.000012864     endif
    5                 0.000008100   endif
                                  
    5                 0.000061140   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                                  
    5                 0.000042764     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    5                 0.000066390     let fileNodeExtension = tolower(fileNodeExtension)
    5                 0.000054175     let fileNode = tolower(fileNode)
                                  
   50                 0.007604410     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
   45                 0.006242736       if match(fileNode, pattern) != -1
                                          let symbol = glyph
                                          break
   45                 0.000076199       endif
   50                 0.000113169     endfor
                                  
    5                 0.000052852     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
    5                 0.000059076       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                          let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
    5                 0.000104066       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
    5                 0.000059289         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
                                        elseif isDirectory == 1
                                          let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
    5                 0.000010775       endif
    5                 0.000008164     endif
                                  
                                    else
                                      let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
    5                 0.000010313   endif
                                  
    5   0.000416264   0.000218857   let artifactFix = s:DevIconsGetArtifactFix()
                                  
    5                 0.000040815   return symbol . artifactFix
                                  

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 18 times
Total time:   0.000367286
 Self time:   0.000367286

count     total (s)      self (s)
   18                 0.000324213   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:65
Called 9 times
Total time:   0.000135243
 Self time:   0.000135243

count     total (s)      self (s)
    9                 0.000112978   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>147_mergeSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:805
Called 4 times
Total time:   0.002761086
 Self time:   0.000708736

count     total (s)      self (s)
    4                 0.000037239     if a:t == 0
                                          call insert(a:data['sourceTalkbacks'], a:d, a:i)
                                          let a:data['startCount'] += 1
                                          if a:data['startCount'] == 1 | call a:data['sink'](0, a:data['talkback']) | endif
    4                 0.000041576     elseif a:t == 2 && !lsp#callbag#isUndefined(a:d)
                                          let a:data['ended'] = 1
                                          let l:j = 0
                                          while l:j < a:data['n']
                                              if l:j != a:i && l:j < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:j] != 0
                                                  call a:data['sourceTalkbacks'][l:j](2, lsp#callbag#undefined())
                                              endif
                                              let l:j += 1
                                          endwhile
                                          call a:data['sink'](2, a:d)
    4                 0.000024139     elseif a:t == 2
                                          let a:data['sourceTalkbacks'][a:i] = 0
                                          let a:data['endCount'] += 1
                                          if a:data['endCount'] == a:data['n'] | call a:data['sink'](2, lsp#callbag#undefined()) | endif
    4                 0.000007362     else
    4   0.002153527   0.000101177         call a:data['sink'](a:t, a:d)
    4                 0.000009650     endif

FUNCTION  <SNR>207_FixList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:76
Called 3 times
Total time:   0.062168487
 Self time:   0.030755384

count     total (s)      self (s)
    3   0.000300048   0.000069602     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    3                 0.000025763     let l:new_list = []
                                  
   51                 0.006472712     for l:item in a:list
   48                 0.000942983         let l:fixed_item = copy(l:item)
                                  
   48   0.032405248   0.001222591         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                                  
   48                 0.005588051         if l:item.bufnr == -1
                                              " If the buffer number is invalid, remove it.
    6                 0.000108779             call remove(l:fixed_item, 'bufnr')
   48                 0.000133140         endif
                                  
   48                 0.000661991         call add(l:new_list, l:fixed_item)
   51                 0.000182042     endfor
                                  
    3                 0.000039938     return l:new_list

FUNCTION  ale#lsp#ReadMessageData()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp.vim:157
Called 2 times
Total time:   0.001874517
 Self time:   0.001874517

count     total (s)      self (s)
    2                 0.000021251     let l:response_list = []
    2                 0.000021487     let l:remainder = a:data
                                  
    4                 0.000021801     while 1
                                          " Look for the end of the HTTP headers
    4                 0.000099478         let l:body_start_index = matchend(l:remainder, "\r\n\r\n")
                                  
    4                 0.000033227         if l:body_start_index < 0
                                              " No header end was found yet.
    2                 0.000005963             break
    2                 0.000003738         endif
                                  
                                          " Parse the Content-Length header.
    2                 0.000040301         let l:header_data = l:remainder[:l:body_start_index - 4]
    2                 0.000085503         let l:length_match = matchlist(   l:header_data,   '\vContent-Length: *(\d+)')
                                  
    2                 0.000019263         if empty(l:length_match)
                                              throw "Invalid JSON-RPC header:\n" . l:header_data
    2                 0.000004550         endif
                                  
                                          " Split the body and the remainder of the text.
    2                 0.000041163         let l:remainder_start_index = l:body_start_index + str2nr(l:length_match[1])
                                  
    2                 0.000037177         if len(l:remainder) < l:remainder_start_index
                                              " We don't have enough data yet.
                                              break
    2                 0.000003513         endif
                                  
    2                 0.000042802         let l:body = l:remainder[l:body_start_index : l:remainder_start_index - 1]
    2                 0.000030364         let l:remainder = l:remainder[l:remainder_start_index :]
                                  
                                          " Parse the JSON object and add it to the list.
    2                 0.001009086         call add(l:response_list, json_decode(l:body))
    4                 0.000028026     endwhile
                                  
    2                 0.000021237     return [l:remainder, l:response_list]

FUNCTION  225()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 2 times
Total time:   0.002087261
 Self time:   0.000059876

count     total (s)      self (s)
    2   0.002082025   0.000054640     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:72
Called 3 times
Total time:   0.002600130
 Self time:   0.002600130

count     total (s)      self (s)
    3                 0.000054227     if s:has_nvim_highlight
                                          call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
    3                 0.000011287     else
   41                 0.000432404         for l:match in getmatches()
   38                 0.001179764             if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
   38                 0.000480654                 call matchdelete(l:match.id)
   38                 0.000107053             endif
   41                 0.000147740         endfor
    3                 0.000006850     endif

FUNCTION  ale#virtualtext#GetGroup()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:105
Called 29 times
Total time:   0.004741292
 Self time:   0.004741292

count     total (s)      self (s)
   29                 0.001637976     let l:type = get(a:item, 'type', 'E')
   29                 0.000620355     let l:sub_type = get(a:item, 'sub_type', '')
                                  
   29                 0.000242793     if l:type is# 'E'
                                          if l:sub_type is# 'style'
                                              return 'ALEVirtualTextStyleError'
                                          endif
                                  
                                          return 'ALEVirtualTextError'
   29                 0.000052579     endif
                                  
   29                 0.000160019     if l:type is# 'W'
   29                 0.000171330         if l:sub_type is# 'style'
                                              return 'ALEVirtualTextStyleWarning'
   29                 0.000056124         endif
                                  
   29                 0.000129753         return 'ALEVirtualTextWarning'
                                      endif
                                  
                                      return 'ALEVirtualTextInfo'

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:460
Called 3 times
Total time:   0.000184031
 Self time:   0.000184031

count     total (s)      self (s)
    3                 0.000092092     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    3                 0.000056839     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                                  
    3                 0.000019125     return l:timer_id

FUNCTION  lsp#utils#path_to_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:124
Called 27 times
Total time:   0.000852905
 Self time:   0.000852905

count     total (s)      self (s)
   27                 0.000455743         if has_key(s:path_to_uri_cache, a:path)
   27                 0.000295023             return s:path_to_uri_cache[a:path]
                                          endif
                                  
                                          if empty(a:path) || lsp#utils#is_remote_uri(a:path)
                                              let s:path_to_uri_cache[a:path] = a:path
                                              return s:path_to_uri_cache[a:path]
                                          else
                                              let s:path_to_uri_cache[a:path] = s:encode_uri(a:path, 0, 'file://')
                                              return s:path_to_uri_cache[a:path]
                                          endif

FUNCTION  <SNR>207_ShouldClose()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:50
Called 1 time
Total time:   0.000124555
 Self time:   0.000071778

count     total (s)      self (s)
    1   0.000090203   0.000037426     let l:val = ale#Var(a:buffer, 'open_list')
    1                 0.000017550     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                  
    1                 0.000012813     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:147
Called 9 times
Total time:   0.004012020
 Self time:   0.004012020

count     total (s)      self (s)
    9                 0.002883953   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
    9                 0.000227357   if g:airline_detect_spell && (&spell || (exists('g:airline_spell_check_command') && eval(g:airline_spell_check_command)))
                                  
                                      if g:airline_detect_spelllang !=? '0' && g:airline_detect_spelllang ==? 'flag'
                                        let spelllang = tolower(&spelllang)
                                        if has_key(s:flags, spelllang)
                                          return s:flags[spelllang]
                                        elseif has_key(s:flags_noregion, spelllang)
                                          return s:flags_noregion[spelllang]
                                        endif
                                      endif
                                  
                                      let winwidth = airline#util#winwidth()
                                      if winwidth >= 90
                                        return g:airline_symbols.spell . spelllang
                                      elseif winwidth >= 70
                                        return g:airline_symbols.spell
                                      elseif !empty(g:airline_symbols.spell)
                                        return split(g:airline_symbols.spell, '\zs')[0]
                                      endif
    9                 0.000015537   endif
    9                 0.000032512   return ''

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:108
Called 3 times
Total time:   0.347128587
 Self time:   0.001856463

count     total (s)      self (s)
    3                 0.000087528     let l:info = get(g:ale_buffer_info, a:buffer, {})
                                  
    3                 0.000031352     if empty(l:info)
                                          return
    3                 0.000005837     endif
                                  
    3                 0.000015688     if !a:from_other_source
                                          " Remove this linter from the list of active linters.
                                          " This may have already been done when the job exits.
    3                 0.000067952         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    3                 0.000009213     endif
                                  
                                      " Make some adjustments to the loclists to fix common problems, and also
                                      " to set default values for loclist items.
    3   0.033070109   0.000098604     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                                  
                                      " Remove previous items for this linter.
    3                 0.000211933     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                                  
                                      " We don't need to add items or sort the list when this list is empty.
    3                 0.000028564     if !empty(l:linter_loclist)
                                          " Add the new items.
    3                 0.000042376         call extend(l:info.loclist, l:linter_loclist)
                                  
                                          " Sort the loclist again.
                                          " We need a sorted list so we can run a binary search against it
                                          " for efficient lookup of the messages in the cursor handler.
    3   0.027121747   0.000942107         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    3                 0.000008701     endif
                                  
    3   0.006335677   0.000089790     if ale#ShouldDoNothing(a:buffer)
                                          return
    3                 0.000005425     endif
                                  
    3   0.279963445   0.000088353     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  coc#util#get_fullpath()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:514
Called 2 times
Total time:   0.000527981
 Self time:   0.000407664

count     total (s)      self (s)
    2                 0.000033576   let nr = a:0 == 0 ? bufnr('%') : a:1
    2                 0.000024138   if !bufloaded(nr)
                                      return ''
    2                 0.000004562   endif
    2                 0.000033102   if s:is_vim && getbufvar(nr, '&buftype') ==# 'terminal'
                                      let job = term_getjob(nr)
                                      let pid = job_info(job)->get('process', 0)
                                      let cwd = fnamemodify(getcwd(), ':~')
                                      return 'term://' . cwd . '//' . pid . ':' . substitute(bufname(nr), '^!', '', '')
    2                 0.000005025   endif
    2                 0.000025225   let name = bufname(nr)
    2   0.000305236   0.000184919   return empty(name) ? '' : coc#util#win32unix_to_node(fnamemodify(name, ':p'))

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:376
Called 3 times
Total time:   0.018971229
 Self time:   0.018562513

count     total (s)      self (s)
    3                 0.000026827     let l:command_list = []
    3                 0.000024538     let l:is_dummy_sign_set = a:was_sign_set
                                  
                                      " Set the dummy sign if we need to.
                                      " The dummy sign is needed to keep the sign column open while we add
                                      " and remove signs.
    3                 0.000054265     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    3   0.000509605   0.000206255         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    3                 0.000025763         let l:is_dummy_sign_set = 1
    3                 0.000008776     endif
                                  
                                      " Place new items first.
   32                 0.000299370     for [l:line_str, l:info] in items(a:sign_map)
   29                 0.000174560         if l:info.new_id
                                              " Save the sign IDs we are setting back on our loclist objects.
                                              " These IDs will be used to preserve items which are set many times.
   69                 0.009416461             for l:item in l:info.items
   40                 0.000345063                 let l:item.sign_id = l:info.new_id
   69                 0.000205308             endfor
                                  
   29                 0.000501905             if index(l:info.current_id_list, l:info.new_id) < 0
    1   0.000086453   0.000049602                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
   29                 0.000107125             endif
   29                 0.000052728         endif
   32                 0.000075854     endfor
                                  
                                      " Remove signs without new IDs.
   32                 0.000178364     for l:info in values(a:sign_map)
   57                 0.000336728         for l:current_id in l:info.current_id_list
   28                 0.000205943             if l:current_id isnot l:info.new_id
                                                  call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
   28                 0.000080688             endif
   57                 0.000120239         endfor
   32                 0.000065539     endfor
                                  
                                      " Remove the dummy sign to close the sign column if we need to.
    3                 0.000029401     if l:is_dummy_sign_set && !g:ale_sign_column_always
    3   0.000337862   0.000269347         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    3                 0.000009989     endif
                                  
    3                 0.000016963     return l:command_list

FUNCTION  <SNR>114_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 1088 times
Total time:   0.315836124
 Self time:   0.315836124

count     total (s)      self (s)
 1088                 0.047915826     let color = ''
 1088                 0.037045727     if hlexists(a:group)
 1088                 0.062209887       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 1088                 0.009755665     endif
 1088                 0.036226841     if empty(color) || color == -1
                                        " should always exist
                                        let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                        " however, just in case
                                        if empty(color) || color == -1
                                          let color = 'NONE'
                                        endif
 1088                 0.001903365     endif
 1088                 0.024154760     return color

FUNCTION  <SNR>206_BuildSignMap()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:307
Called 3 times
Total time:   0.040668868
 Self time:   0.021626676

count     total (s)      self (s)
    3   0.000283648   0.000069253     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                                  
    3                 0.000024839     if l:max_signs is 0
                                          let l:selected_grouped_items = []
    3                 0.000048415     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                          let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    3                 0.004075433     else
    3                 0.000056590         let l:selected_grouped_items = a:grouped_items
    3                 0.000009313     endif
                                  
    3                 0.000025626     let l:sign_map = {}
    3                 0.000024913     let l:sign_offset = g:ale_sign_offset
                                  
   31                 0.000226447     for [l:line, l:sign_id, l:name] in a:current_sign_list
   28                 0.000966972         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                                  
                                          " Increment the sign offset for new signs, by the maximum sign ID.
   28                 0.000219359         if l:sign_id > l:sign_offset
    7                 0.000052027             let l:sign_offset = l:sign_id
   28                 0.000062543         endif
                                  
                                          " Remember the sign names and IDs in separate Lists, so they are easy
                                          " to work with.
   28                 0.000344120         call add(l:sign_info.current_id_list, l:sign_id)
   28                 0.001004600         call add(l:sign_info.current_name_list, l:name)
                                  
   28                 0.000358962         let l:sign_map[l:line] = l:sign_info
   31                 0.000112811     endfor
                                  
   32                 0.000168609     for l:group in l:selected_grouped_items
   29                 0.000363627         let l:line = l:group[0].lnum
   29                 0.000881981         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                                  
   29   0.020614339   0.001786542         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   29                 0.000255651         let l:sign_info.items = l:group
                                  
   29                 0.007530682         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                                  
   29                 0.000226067         if l:index >= 0
                                              " We have a sign with this name already, so use the same ID.
   28                 0.000609175             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    1                 0.000002300         else
                                              " This sign name replaces the previous name, so use a new ID.
    1                 0.000009325             let l:sign_info.new_id = l:sign_offset + 1
    1                 0.000009463             let l:sign_offset += 1
   29                 0.000063101         endif
                                  
   29                 0.000320549         let l:sign_map[l:line] = l:sign_info
   32                 0.000116332     endfor
                                  
    3                 0.000017301     return l:sign_map

FUNCTION  ale#path#Simplify()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:15
Called 10 times
Total time:   0.001465464
 Self time:   0.001465464

count     total (s)      self (s)
   10                 0.000135016     if has('unix')
   10                 0.000848644         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                                  
   10                 0.000426477         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                      endif
                                  
                                      let l:win_path = substitute(a:path, '/', '\\', 'g')
                                  
                                      return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>71_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:261
Called 6 times
Total time:   0.018415797
 Self time:   0.000464078

count     total (s)      self (s)
    6                 0.000164642   if !get(g:, 'coc_workspace_initialized', 0)
                                      return
    6                 0.000021337   endif
    6   0.018140774   0.000189055   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:84
Called 3 times
Total time:   0.000399089
 Self time:   0.000399089

count     total (s)      self (s)
    3                 0.000392226     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  lsp#utils#normalize_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:176
Called 27 times
Total time:   0.000246048
 Self time:   0.000246048

count     total (s)      self (s)
   27                 0.000195621         return a:uri

FUNCTION  <SNR>214_CreateCountDict()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:5
Called 1 time
Total time:   0.000027963
 Self time:   0.000027963

count     total (s)      self (s)
                                      " Keys 0 and 1 are for backwards compatibility.
                                      " The count object used to be a List of [error_count, warning_count].
    1                 0.000022364     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 9 times
Total time:   0.001922007
 Self time:   0.000586612

count     total (s)      self (s)
    9   0.000415354   0.000212511   let part = airline#parts#get('mode')
    9                 0.000122766   let minwidth = get(part, 'minwidth', 79)
    9   0.001346649   0.000214097   return airline#util#shorten(get(w:, 'airline_current_mode', ''), minwidth, 1)

FUNCTION  <SNR>101_airline_ale_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:11
Called 14 times
Total time:   0.000194007
 Self time:   0.000194007

count     total (s)      self (s)
   14                 0.000161179   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>114_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 272 times
Total time:   0.007114412
 Self time:   0.007114412

count     total (s)      self (s)
  272                 0.006449036     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>214_GetFirstProblems()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:108
Called 7 times
Total time:   0.000958471
 Self time:   0.000439140

count     total (s)      self (s)
    7   0.000391813   0.000126291     if !s:BufferCacheExists(a:buffer)
                                          return {}
    7                 0.000015226     endif
                                  
    7   0.000374801   0.000120992     call s:UpdateCacheIfNecessary(a:buffer)
                                  
    7                 0.000078078     return g:ale_buffer_info[a:buffer].first_problems

FUNCTION  ale#util#GetMatches()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:325
Called 3 times
Total time:   0.016281233
 Self time:   0.016281233

count     total (s)      self (s)
    3                 0.000581221     let l:matches = []
    3                 0.000062752     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    3                 0.000054652     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                                  
   41                 0.000263734     for l:line in l:lines
   64                 0.000410892         for l:pattern in l:patterns
   38                 0.004044319             let l:match = matchlist(l:line, l:pattern)
                                  
   38                 0.003493666             if !empty(l:match)
   12                 0.000164244                 call add(l:matches, l:match)
   12                 0.000040839                 break
   26                 0.000045978             endif
   64                 0.000143228         endfor
   41                 0.000236042     endfor
                                  
    3                 0.000026152     return l:matches

FUNCTION  <SNR>207_ShouldOpen()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:41
Called 3 times
Total time:   0.000355401
 Self time:   0.000174657

count     total (s)      self (s)
    3   0.000242746   0.000062002     let l:val = ale#Var(a:buffer, 'open_list')
    3                 0.000055465     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                  
    3                 0.000041463     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  ale#hover#HandleLSPResponse()
    Defined: ~/.vim/plugged/ale/autoload/ale/hover.vim:211
Called 2 times
Total time:   0.000541908
 Self time:   0.000541908

count     total (s)      self (s)
    2                 0.000035677     if has_key(a:response, 'id')&& has_key(s:hover_map, a:response.id)
                                          let l:options = remove(s:hover_map, a:response.id)
                                  
                                          " If the call did __not__ come from balloonexpr...
                                          if !get(l:options, 'hover_from_balloonexpr', 0)
                                              let l:buffer = bufnr('')
                                              let [l:line, l:column] = getpos('.')[1:2]
                                              let l:end = len(getline(l:line))
                                  
                                              if l:buffer isnot l:options.buffer|| l:line isnot l:options.line|| min([l:column, l:end]) isnot min([l:options.column, l:end])
                                                  " ... Cancel display the message if the cursor has moved.
                                                  return
                                              endif
                                          endif
                                  
                                          " The result can be a Dictionary item, a List of the same, or null.
                                          let l:result = get(a:response, 'result', v:null)
                                  
                                          if l:result is v:null
                                              return
                                          endif
                                  
                                          let [l:commands, l:lines] = ale#hover#ParseLSPResult(l:result.contents)
                                  
                                          if !empty(l:lines)
                                              let l:set_balloons = ale#Var(l:options.buffer, 'set_balloons')
                                  
                                              if get(l:options, 'hover_from_balloonexpr', 0)&& exists('*balloon_show')&& (l:set_balloons is 1 || l:set_balloons is# 'hover')
                                                  call balloon_show(join(l:lines, "\n"))
                                              elseif get(l:options, 'truncated_echo', 0)
                                                  if type(l:lines[0]) is# v:t_list
                                                      call ale#cursor#TruncatedEcho(join(l:lines[0], '\n'))
                                                  else
                                                      call ale#cursor#TruncatedEcho(l:lines[0])
                                                  endif
                                              elseif g:ale_hover_to_floating_preview || g:ale_floating_preview
                                                  call ale#floating_preview#Show(l:lines, {   'filetype': 'ale-preview.message',   'commands': l:commands,})
                                              elseif g:ale_hover_to_preview
                                                  call ale#preview#Show(l:lines, {   'filetype': 'ale-preview.message',   'stay_here': 1,   'commands': l:commands,})
                                              else
                                                  call ale#util#ShowMessage(join(l:lines, "\n"), {   'commands': l:commands,})
                                              endif
                                          endif
    2                 0.000003337     endif

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:218
Called 9 times
Total time:   0.007926232
 Self time:   0.007926232

count     total (s)      self (s)
    9                 0.007493380   if has_key(s:contexts, a:winnr)
    9                 0.000355264     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                                    endif
                                    " in rare circumstances this happens...see #276
                                    return ''

FUNCTION  <SNR>206_UpdateLineNumbers()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:282
Called 3 times
Total time:   0.022738713
 Self time:   0.022738713

count     total (s)      self (s)
    3                 0.000035463     let l:line_map = {}
    3                 0.000024826     let l:line_numbers_changed = 0
                                  
   31                 0.000243199     for [l:line, l:sign_id, l:name] in a:current_sign_list
   28                 0.001807137         let l:line_map[l:sign_id] = l:line
   31                 0.000126195     endfor
                                  
   53                 0.000389153     for l:item in a:loclist
   50                 0.010397694         if l:item.bufnr == a:buffer
   40                 0.007594284             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                                  
   40                 0.000473503             if l:lnum && l:item.lnum != l:lnum
                                                  let l:item.lnum = l:lnum
                                                  let l:line_numbers_changed = 1
   40                 0.000228196             endif
   50                 0.000085766         endif
   53                 0.000119905     endfor
                                  
                                      " When the line numbers change, sort the list again
    3                 0.000018151     if l:line_numbers_changed
                                          call sort(a:loclist, 'ale#util#LocItemCompare')
    3                 0.000008100     endif

FUNCTION  <SNR>207_Deduplicate()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:57
Called 3 times
Total time:   0.314850818
 Self time:   0.001724848

count     total (s)      self (s)
    3                 0.000027589     let l:list = a:list
                                  
    3   0.294033074   0.001113939     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    3   0.020734467   0.000527632     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                                  
    3                 0.000018925     return l:list

FUNCTION  coc#util#win32unix_to_node()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:621
Called 2 times
Total time:   0.000120317
 Self time:   0.000120317

count     total (s)      self (s)
    2                 0.000015362   if s:is_win32unix
                                      let fullpath = coc#util#fix_home(a:filepath)
                                      if strpart(fullpath, 0, s:win32unix_prefix_len) ==# s:win32unix_prefix
                                        let part = strpart(fullpath, s:win32unix_prefix_len)
                                        return toupper(part[0]) . ':' . substitute(part[1:], '/', '\', 'g')
                                      endif
    2                 0.000003413   endif
    2                 0.000010238   return a:filepath

FUNCTION  <SNR>147_fromEventHandlerCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:504
Called 4 times
Total time:   0.003263568
 Self time:   0.000442505

count     total (s)      self (s)
                                      " send v:event if it exists
    4   0.003217365   0.000396302     call a:data['sink'](1, lsp#callbag#undefined())

FUNCTION  <lambda>24()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp.vim:555
Called 2 times
Total time:   0.004386169
 Self time:   0.000237283

count     total (s)      self (s)
                                  return ale#lsp#HandleMessage(a:conn_id, message)

FUNCTION  <lambda>26()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:262
Called 344 times
Total time:   0.004794731
 Self time:   0.004794731

count     total (s)      self (s)
                                  return 0

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:30
Called 27 times
Total time:   0.003353494
 Self time:   0.001853354

count     total (s)      self (s)
   27   0.002138777   0.000638637   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                      if get(a:000, 0, 0)
                                        " shorten from tail
                                        return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                      else
                                        " shorten from beginning of string
                                        return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                      endif
   27                 0.000046727   else
   27                 0.000131028     return a:text
                                    endif

FUNCTION  <lambda>32()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:262
Called 1 time
Total time:   0.000009976
 Self time:   0.000009976

count     total (s)      self (s)
                                  return 0

FUNCTION  <lambda>39()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 2 times
Total time:   0.000010201
 Self time:   0.000010201

count     total (s)      self (s)
                                  return g:lsp_document_highlight_enabled

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:212
Called 4 times
Total time:   0.029711640
 Self time:   0.005069559

count     total (s)      self (s)
    4                 0.000232820     if getbufvar(a:bufnr, '&modified')
                                        let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4                 0.000024614     else
    4                 0.000221808       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4                 0.000025225     endif
                                  
    4                 0.002221780     if !empty(colors)
    4   0.024976219   0.000334138       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4                 0.000017488     endif

FUNCTION  <lambda>40()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 2 times
Total time:   0.000116878
 Self time:   0.000116878

count     total (s)      self (s)
                                  return {'bufnr': bufnr('%'), 'curpos': getcurpos()[0:2], 'changedtick': b:changedtick }

FUNCTION  <lambda>41()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_highlight.vim:19
Called 2 times
Total time:   0.000032763
 Self time:   0.000032763

count     total (s)      self (s)
                                  return a['bufnr'] == b['bufnr'] && a['curpos'] == b['curpos'] && a['changedtick'] == b['changedtick']

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:83
Called 1 time
Total time:   0.000459167
 Self time:   0.000416503

count     total (s)      self (s)
    1                 0.000019713     let l:info = get(s:buffer_data, a:buffer, {})
                                  
    1                 0.000014450     if !empty(l:info) && empty(l:info.jobs)
                                          " We can't delete anything in a sandbox, so wait until we escape from
                                          " it to delete temporary files and directories.
    1   0.000053440   0.000010776         if ale#util#InSandbox()
                                              return
    1                 0.000001875         endif
                                  
                                          " Delete files with a call akin to a plan `rm` command.
    1                 0.000008675         for l:filename in l:info.file_list
                                              call delete(l:filename)
    1                 0.000003088         endfor
                                  
                                          " Delete directories like `rm -rf`.
                                          " Directories are handled differently from files, so paths that are
                                          " intended to be single files can be set up for automatic deletion
                                          " without accidentally deleting entire directories.
    2                 0.000012876         for l:directory in l:info.directory_list
    1                 0.000220183             call delete(l:directory, 'rf')
    2                 0.000007300         endfor
                                  
    1                 0.000015250         call remove(s:buffer_data, a:buffer)
    1                 0.000062915     endif

FUNCTION  lsp#log_verbose()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:39
Called 1 time
Total time:   0.000108354
 Self time:   0.000060115

count     total (s)      self (s)
    1                 0.000008013     if g:lsp_log_verbose
    1   0.000093741   0.000045502         call call(function('lsp#log'), a:000)
    1                 0.000002587     endif

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:65
Called 63 times
Total time:   0.013899037
 Self time:   0.013899037

count     total (s)      self (s)
   63                 0.000833253   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
   63                 0.000148863   endif
   63                 0.006971244   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:83
Called 27 times
Total time:   0.003108050
 Self time:   0.002862002

count     total (s)      self (s)
   27   0.003048548   0.002802500     return get(s:diagnostics_state, lsp#utils#normalize_uri(a:uri), {})

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:118
Called 2 times
Total time:   0.000599121
 Self time:   0.000529805

count     total (s)      self (s)
    2                 0.000096103     let l:buffer = bufnr('')
                                  
    2                 0.000024239     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
    2                 0.000008038     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
    2                 0.000038189     if mode(1) isnot# 'n'
                                          return
    2                 0.000003862     endif
                                  
    2   0.000171944   0.000102628     call s:StopCursorTimer()
                                  
    2                 0.000065652     let l:pos = getpos('.')[0:2]
                                  
    2                 0.000026339     if !exists('w:last_pos')
                                          let w:last_pos = [0, 0, 0]
    2                 0.000004825     endif
                                  
                                      " Check the current buffer, line, and column number against the last
                                      " recorded position. If the position has actually changed, *then*
                                      " we should echo something. Otherwise we can end up doing processing
                                      " the echo message far too frequently.
    2                 0.000017038     if l:pos != w:last_pos
                                          let l:delay = ale#Var(l:buffer, 'echo_delay')
                                  
                                          let w:last_pos = l:pos
                                          let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    2                 0.000005151     endif

FUNCTION  <lambda>74()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 2 times
Total time:   0.000007263
 Self time:   0.000007263

count     total (s)      self (s)
                                  return g:lsp_document_code_action_signs_enabled

FUNCTION  <lambda>75()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 2 times
Total time:   0.000121517
 Self time:   0.000121517

count     total (s)      self (s)
                                  return {'bufnr': bufnr('%'), 'curpos': getcurpos()[0:2], 'changedtick': b:changedtick }

FUNCTION  <lambda>76()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/document_code_action/signs.vim:28
Called 2 times
Total time:   0.000085103
 Self time:   0.000085103

count     total (s)      self (s)
                                  return a['bufnr'] == b['bufnr'] && a['curpos'] == b['curpos'] && a['changedtick'] == b['changedtick']

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:142
Called 6 times
Total time:   0.000168893
 Self time:   0.000168893

count     total (s)      self (s)
    6                 0.000060927   if s:is_vim
    6                 0.000075466     return a:client['channel']
                                    endif
                                    return a:client['chan_id']

FUNCTION  <SNR>207_CloseWindowIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:242
Called 1 time
Total time:   0.000218571
 Self time:   0.000043927

count     total (s)      self (s)
    1   0.000211333   0.000036689     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
    1                 0.000004687         return
                                      endif
                                  
                                      let l:did_close_any_list = 0
                                  
                                      try
                                          " Only close windows if the quickfix list or loclist is completely empty,
                                          " including errors set through other means.
                                          if g:ale_set_quickfix
                                              if empty(getqflist())
                                                  cclose
                                                  let l:did_close_any_list = 1
                                              endif
                                          else
                                              let l:win_ids = s:WinFindBuf(a:buffer)
                                  
                                              for l:win_id in l:win_ids
                                                  if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                      lclose
                                                      let l:did_close_any_list = 1
                                                  endif
                                              endfor
                                          endif
                                      " Ignore 'Cannot close last window' errors.
                                      catch /E444/
                                      endtry
                                  
                                      if l:did_close_any_list
                                          call s:RestoreViewIfNeeded(a:buffer)
                                      endif

FUNCTION  <SNR>114_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 192 times
Total time:   0.037560325
 Self time:   0.037560325

count     total (s)      self (s)
                                      " Checks, whether the definition of the colors is valid and is not empty or NONE
                                      " e.g. if the colors would expand to this:
                                      " hi airline_c ctermfg=NONE ctermbg=NONE
                                      " that means to clear that highlighting group, therefore, fallback to Normal
                                      " highlighting group for the cterm values
                                  
                                      " This only works, if the Normal highlighting group is actually defined, so
                                      " return early, if it has been cleared
  192                 0.002979650     if !exists("g:airline#highlighter#normal_fg_hi")
                                        let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  192                 0.000580186     endif
  192                 0.010527624     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                        return a:colors
  192                 0.002497479     endif
                                  
  192                 0.002240635     for val in a:colors
  192                 0.004023944       if !empty(val) && val !=# 'NONE'
  192                 0.001221317         return a:colors
                                        endif
                                      endfor
                                      " this adds the bold attribute to the term argument of the :hi command,
                                      " but at least this makes sure, the group will be defined
                                      let fg = g:airline#highlighter#normal_fg_hi
                                      let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                      if empty(bg) || bg < 0
                                        " in case there is no background color defined for Normal
                                        let bg = a:colors[3]
                                      endif
                                      return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:172
Called 9 times
Total time:   0.000265861
 Self time:   0.000265861

count     total (s)      self (s)
    9                 0.000107903   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                      return toupper(b:keymap_name)
    9                 0.000023175   endif
    9                 0.000032387   return ''

FUNCTION  lsp#callbag#undefined()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:7
Called 8 times
Total time:   0.000121504
 Self time:   0.000121504

count     total (s)      self (s)
    8                 0.000091427     return s:undefined_token

FUNCTION  <SNR>61_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:554
Called 5 times
Total time:   0.000197407
 Self time:   0.000197407

count     total (s)      self (s)
    5                 0.000045415   if g:DevIconsAppendArtifactFix == 1
                                      let artifactFix = g:DevIconsArtifactFixChar
    5                 0.000011301   else
    5                 0.000033726     let artifactFix = ''
    5                 0.000013051   endif
                                  
    5                 0.000035065   return artifactFix

FUNCTION  <SNR>208_matchaddpos()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:89
Called 40 times
Total time:   0.030528058
 Self time:   0.030528058

count     total (s)      self (s)
   40                 0.000322738     if s:has_nvim_highlight
                                          for l:pos in a:pos_list
                                              let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                                  
                                              if type(l:pos) == v:t_number || len(l:pos) == 1
                                                  let l:col_start = 0
                                                  let l:col_end = s:MAX_COL_SIZE
                                              else
                                                  let l:col_start = l:pos[1] - 1
                                                  let l:col_end = l:col_start + get(l:pos, 2, 1)
                                              endif
                                  
                                              call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
                                          endfor
   40                 0.000092743     else
   40                 0.023224816         call matchaddpos(a:group, a:pos_list)
   40                 0.000204908     endif

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:51
Called 72 times
Total time:   0.076008126
 Self time:   0.076008126

count     total (s)      self (s)
   72                 0.000951310   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
   72                 0.000166184   endif
   72                 0.073253507   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   72                 0.001036528   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>101_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:130
Called 3 times
Total time:   0.000189432
 Self time:   0.000189432

count     total (s)      self (s)
    3                 0.000079503   if !exists('#airline')
                                      " airline disabled
                                      return
    3                 0.000006138   endif
    3                 0.000048464   if get(g:, 'airline_skip_empty_sections', 0)
                                      exe ':AirlineRefresh!'
    3                 0.000006225   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 80 times
Total time:   0.135043382
 Self time:   0.002328621

count     total (s)      self (s)
   80   0.134894834   0.002180073     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  lsp#utils#iteratable()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils.vim:521
Called 27 times
Total time:   0.000606063
 Self time:   0.000606063

count     total (s)      self (s)
   27                 0.000540748     return type(a:list) !=# v:t_list ? [] : a:list

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:39
Called 9 times
Total time:   0.001448524
 Self time:   0.000370048

count     total (s)      self (s)
                                    " Shorten text for windows < 91 characters
    9   0.001308060   0.000229584   let status = airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)
    9                 0.000092616   return (s:show_coc_status ? status : '')

FUNCTION  <SNR>136_FindHistoryItem()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:36
Called 6 times
Total time:   0.002235530
 Self time:   0.002003034

count     total (s)      self (s)
                                      " Search backwards to find a matching job ID. IDs might be recycled,
                                      " so finding the last one should be good enough.
   68   0.000903755   0.000671259     for l:obj in reverse(ale#history#Get(a:buffer))
   68                 0.000554084         if l:obj.job_id == a:job_id
    6                 0.000029350             return l:obj
   62                 0.000123632         endif
   62                 0.000243123     endfor
                                  
                                      return {}

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:790
Called 2 times
Total time:   0.000325650
 Self time:   0.000200183

count     total (s)      self (s)
    2                 0.000020851   let invalids = []
    2   0.000187344   0.000061877   let ids = coc#float#get_float_win_list(1)
    2                 0.000015151   for id in ids
                                      let target = getwinvar(id, 'target_winid', 0)
                                      if target && index(ids, target) == -1
                                        call add(invalids, id)
                                      endif
    2                 0.000005563   endfor
    2                 0.000011088   for id in invalids
                                      call coc#float#close(id)
    2                 0.000006026   endfor

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:284
Called 3 times
Total time:   0.000448153
 Self time:   0.000269384

count     total (s)      self (s)
    3   0.000248784   0.000070015     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                                  
    3                 0.000034090     if type(l:linter_mappings) is v:t_list
                                          return l:linter_mappings
    3                 0.000006675     endif
                                  
    3                 0.000020176     let l:name = a:name
                                  
    3                 0.000033102     if !has_key(l:linter_mappings, l:name)
                                          " Use * as a default setting for all tools.
    3                 0.000019662         let l:name = '*'
    3                 0.000007649     endif
                                  
    3                 0.000033351     return get(l:linter_mappings, l:name, [])

FUNCTION  ale#lsp#HandleMessage()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp.vim:370
Called 2 times
Total time:   0.004148886
 Self time:   0.000658509

count     total (s)      self (s)
    2                 0.000043852     let l:conn = get(s:connections, a:conn_id, {})
                                  
    2                 0.000020439     if empty(l:conn)
                                          return
    2                 0.000004200     endif
                                  
    2                 0.000026038     if type(a:message) isnot v:t_string
                                          " Ignore messages that aren't strings.
                                          return
    2                 0.000003837     endif
                                  
    2                 0.000034414     let l:conn.data .= a:message
                                  
                                      " Parse the objects now if we can, and keep the remaining text.
    2   0.001950783   0.000076266     let [l:conn.data, l:response_list] = ale#lsp#ReadMessageData(l:conn.data)
                                  
                                      " Look for initialize responses first.
    2                 0.000014575     if !l:conn.initialized
                                          for l:response in l:response_list
                                              call ale#lsp#HandleInitResponse(l:conn, l:response)
                                          endfor
    2                 0.000003725     endif
                                  
                                      " If the connection is marked as initialized, call the callbacks with the
                                      " responses.
    2                 0.000010450     if l:conn.initialized
    4                 0.000023452         for l:response in l:response_list
                                              " Call all of the registered handlers with the response.
    6                 0.000042801             for l:Callback in l:conn.callback_list
    4   0.001754913   0.000139053                 call ale#util#GetFunction(l:Callback)(a:conn_id, l:response)
    6                 0.000019287             endfor
    4                 0.000009776         endfor
    2                 0.000003876     endif

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:136
Called 3 times
Total time:   0.061658069
 Self time:   0.024159132

count     total (s)      self (s)
    3                 0.000070891     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                                  
    3   0.008928394   0.006328264     call ale#highlight#RemoveHighlights()
                                  
   43                 0.000337489     for l:item in l:item_list
   40                 0.000438739         if l:item.type is# 'W'
   40                 0.000879792             if get(l:item, 'sub_type', '') is# 'style'
                                                  let l:group = 'ALEStyleWarning'
   40                 0.000103539             else
   40                 0.000297536                 let l:group = 'ALEWarning'
   40                 0.000101410             endif
                                          elseif l:item.type is# 'I'
                                              let l:group = 'ALEInfo'
                                          elseif get(l:item, 'sub_type', '') is# 'style'
                                              let l:group = 'ALEStyleError'
                                          else
                                              let l:group = 'ALEError'
   40                 0.000077663         endif
                                  
   40                 0.007615738         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                                  
   40   0.038826614   0.003927807         call s:highlight_range(l:item.bufnr, l:range, l:group)
   43                 0.000187118     endfor
                                  
                                      " If highlights are enabled and signs are not enabled, we should still
                                      " offer line highlights by adding a separate set of highlights.
    3                 0.000018776     if !g:ale_set_signs
                                          let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                                  
                                          for l:item in l:item_list
                                              if l:item.type is# 'W'
                                                  let l:group = 'ALEWarningLine'
                                              elseif l:item.type is# 'I'
                                                  let l:group = 'ALEInfoLine'
                                              else
                                                  let l:group = 'ALEErrorLine'
                                              endif
                                  
                                              if l:available_groups[l:group]
                                                  call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                              endif
                                          endfor
    3                 0.000007788     endif

FUNCTION  coc#api#Call()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:1354
Called 2 times
Total time:   0.005296640
 Self time:   0.001729612

count     total (s)      self (s)
    2                 0.000065627   let err = v:null
    2                 0.000016487   let result = v:null
    2                 0.000009989   try
    2   0.003594728   0.001432913     let result = call($'coc#api#{toupper(a:method[0])}{strpart(a:method, 1)}', a:args)
    2   0.001485703   0.000080490     call coc#api#Buf_flush(bufnr('%'))
                                    catch /.*/
                                      let err =  v:exception .. " - on request \"" .. a:method .. "\" \n" .. v:throwpoint
                                      let result = v:null
    2                 0.000013050   endtry
    2                 0.000022651   return [err, result]

FUNCTION  <SNR>206_GroupLoclistItems()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:261
Called 3 times
Total time:   0.004579977
 Self time:   0.004579977

count     total (s)      self (s)
    3                 0.000074941     let l:grouped_items = []
    3                 0.000028676     let l:last_lnum = -1
                                  
   53                 0.000992012     for l:obj in a:loclist
   50                 0.000890718         if l:obj.bufnr != a:buffer
   10                 0.000042515             continue
   40                 0.000067708         endif
                                  
                                          " Create a new sub-List when we hit a new line.
   40                 0.000244360         if l:obj.lnum != l:last_lnum
   29                 0.000365209             call add(l:grouped_items, [])
   40                 0.000103897         endif
                                  
   40                 0.000659433         call add(l:grouped_items[-1], l:obj)
   40                 0.000363802         let l:last_lnum = l:obj.lnum
   43                 0.000175359     endfor
                                  
    3                 0.000026364     return l:grouped_items

FUNCTION  lsp#log()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:45
Called 1 time
Total time:   0.000048239
 Self time:   0.000048239

count     total (s)      self (s)
    1                 0.000016050     if !empty(g:lsp_log_file)
                                          call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
    1                 0.000003250     endif

FUNCTION  <SNR>114_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 36 times
Total time:   0.060184306
 Self time:   0.060184306

count     total (s)      self (s)
                                      " a:list needs to have 5 items!
   36                 0.000304032     let res = ''
   36                 0.000287525     let i = -1
  216                 0.001306281     while i < 4
  180                 0.014076955       let i += 1
  180                 0.002461489       let item = get(a:list, i, '')
  180                 0.001280549       if item is ''
   28                 0.000094265         continue
  152                 0.001444288       endif
  152                 0.000811936       if i == 0
   36                 0.000418562         let res .= ' guifg='.item
  116                 0.000626274       elseif i == 1
   36                 0.000345500         let res .= ' guibg='.item
   80                 0.000433661       elseif i == 2
   36                 0.000337125         let res .= ' ctermfg='.item
   44                 0.000202254       elseif i == 3
   36                 0.001858706         let res .= ' ctermbg='.item
    8                 0.000035838       elseif i == 4
    8                 0.000151970         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  152                 0.000426032       endif
  188                 0.000531183     endwhile
   36                 0.000247024     return res

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:17
Called 18 times
Total time:   0.016950432
 Self time:   0.016950432

count     total (s)      self (s)
   18                 0.000483055   if !exists(':CocCommand') | return '' | endif
                                  
   18                 0.000200584   let is_err = (a:type  is# 'error')
   18                 0.000313772   let info = get(b:, 'coc_diagnostic_info', {})
   18                 0.000329600   if empty(info) | return '' | endif
                                  
   18                 0.000227485   let cnt = get(info, a:type, 0)
   18                 0.006104068   if empty(cnt) | return '' | endif
                                  
    9                 0.001743299   let error_symbol = get(g:, 'airline#extensions#coc#error_symbol', 'E:')
    9                 0.000198058   let warning_symbol = get(g:, 'airline#extensions#coc#warning_symbol', 'W:')
    9                 0.000127106   let error_format = get(g:, 'airline#extensions#coc#stl_format_err', '%C(L%L)')
    9                 0.000126680   let warning_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%C(L%L)')
                                  
                                    " replace %C with error count and %L with line number
    9                 0.006890336   return (is_err ? error_symbol : warning_symbol) . substitute(substitute(is_err ? error_format : warning_format, '%C', cnt, 'g'), '%L', (info.lnums)[is_err ? 0 : 1], 'g')

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:39
Called 5 times
Total time:   0.000153730
 Self time:   0.000153730

count     total (s)      self (s)
    5                 0.000096653   if exists('s:current_buffer_list')
    5                 0.000037050     return s:current_buffer_list
                                    endif
                                  
                                    let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                                    let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                                    let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                                  
                                    let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                                  
                                    let buffers = []
                                    " If this is too slow, we can switch to a different algorithm.
                                    " Basically branch 535 already does it, but since it relies on
                                    " BufAdd autocommand, I'd like to avoid this if possible.
                                    for nr in list
                                      if buflisted(nr)
                                        " Do not add to the bufferlist, if either
                                        " 1) bufnr is exclude_buffers list
                                        " 2) buffername matches one of exclude_paths patterns
                                        " 3) buffer is a quickfix buffer
                                        " 4) when excluding preview windows:
                                        "     'bufhidden' == wipe
                                        "     'buftype' == nofile
                                        " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  
                                        " check buffer numbers first
                                        if index(exclude_buffers, nr) >= 0
                                          continue
                                        " check paths second
                                        elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                          continue
                                        " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                        elseif airline#util#ignore_buf(bufname(nr))
                                          continue
                                        " check other types last
                                        elseif s:ExcludeOther(nr, exclude_preview)
                                          continue
                                        endif
                                  
                                        call add(buffers, nr)
                                      endif
                                    endfor
                                  
                                    let s:current_buffer_list = buffers
                                    return buffers

FUNCTION  <SNR>102_airline_lsp_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:15
Called 18 times
Total time:   0.024650360
 Self time:   0.001020964

count     total (s)      self (s)
   18                 0.000151692   let result = ''
                                  
   18                 0.000147381   if a:type ==# 'error'
    9   0.023834327   0.000204931     let result = lsp#get_buffer_first_error_line()
   18                 0.000053604   endif
                                  
   18                 0.000175345   if empty(result)
   18                 0.000111716       return ''
                                    endif
                                  
                                    let open_lnum_symbol  = get(g:, 'airline#extensions#lsp#open_lnum_symbol', '(L')
                                    let close_lnum_symbol = get(g:, 'airline#extensions#lsp#close_lnum_symbol', ')')
                                  
                                    return open_lnum_symbol . result . close_lnum_symbol

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:58
Called 3 times
Total time:   0.001040987
 Self time:   0.000103715

count     total (s)      self (s)
    3   0.001002885   0.000065613     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                                  
    3                 0.000026900     let l:obj.output = a:output

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:29
Called 4 times
Total time:   0.006846458
 Self time:   0.002146039

count     total (s)      self (s)
                                      " The checks are split into separate if statements to make it possible to
                                      " profile each check individually with Vim's profiling tools.
                                      "
                                      " Do nothing if ALE is disabled.
    4                 0.000146581     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                          return 1
    4                 0.000008962     endif
                                  
                                      " Don't perform any checks when newer NeoVim versions are exiting.
    4                 0.000080840     if get(v:, 'exiting', v:null) isnot v:null
                                          return 1
    4                 0.000008675     endif
                                  
    4                 0.000089165     let l:filetype = getbufvar(a:buffer, '&filetype')
                                  
                                      " Do nothing when there's no filetype.
    4                 0.000028814     if l:filetype is# ''
                                          return 1
    4                 0.000008575     endif
                                  
                                      " Do nothing for diff buffers.
    4                 0.000055340     if getbufvar(a:buffer, '&diff')
                                          return 1
    4                 0.000008901     endif
                                  
                                      " Do nothing for blacklisted files.
    4                 0.000083854     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                          return 1
    4                 0.000010563     endif
                                  
                                      " Do nothing if running from command mode.
    4                 0.000086928     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                          return 1
    4                 0.000008914     endif
                                  
    4                 0.000090903     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                                  
                                      " Do nothing for directories.
    4                 0.000029188     if l:filename is# '.'
                                          return 1
    4                 0.000008725     endif
                                  
                                      " Don't start linting and so on when an operator is pending.
    4   0.000217182   0.000106465     if ale#util#Mode(1) is# 'no'
                                          return 1
    4                 0.000009488     endif
                                  
                                      " Do nothing if running in the sandbox.
    4   0.004440047   0.000061153     if ale#util#InSandbox()
                                          return 1
    4                 0.000008426     endif
                                  
                                      " Do nothing if the file is too large.
    4   0.000302298   0.000091490     if ale#FileTooLarge(a:buffer)
                                          return 1
    4                 0.000008925     endif
                                  
                                      " Do nothing from CtrlP buffers with CtrlP-funky.
    4                 0.000179444     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                          return 1
    4                 0.000008914     endif
                                  
    4                 0.000014237     return 0

FUNCTION  <SNR>61_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:409
Called 2 times
Total time:   0.002216118
 Self time:   0.000128857

count     total (s)      self (s)
    2                 0.000028726   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                      return
    2                 0.000003901   endif
                                  
    2   0.002153452   0.000066191   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    2                 0.000008450     return
                                    endif
                                  
                                    " Do not update when a special buffer is selected
                                    if !empty(&l:buftype)
                                      return
                                    endif
                                  
                                    " winnr need to make focus go to opened file
                                    " CursorToTreeWin needed to avoid error on opening file
                                    let l:winnr = winnr()
                                    let l:altwinnr = winnr('#')
                                  
                                    call g:NERDTree.CursorToTreeWin()
                                    call b:NERDTree.root.refreshFlags()
                                    call NERDTreeRender()
                                  
                                    exec l:altwinnr . 'wincmd w'
                                    exec l:winnr . 'wincmd w'

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
    Defined: ~/.vim/plugged/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim:6
Called 5 times
Total time:   0.023071488
 Self time:   0.000572670

count     total (s)      self (s)
                                    " Call original formatter.
    5   0.006594148   0.000318274   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
    5   0.016446213   0.000223269   return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding

FUNCTION  ale#statusline#FirstProblem()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:127
Called 7 times
Total time:   0.007645186
 Self time:   0.006686715

count     total (s)      self (s)
    7   0.001128203   0.000169732     let l:first_problems = s:GetFirstProblems(a:buffer)
                                  
    7                 0.006277424     if !empty(l:first_problems) && has_key(l:first_problems, a:type)
    7                 0.000202094         return copy(l:first_problems[a:type])
                                      endif
                                  
                                      return {}

FUNCTION  <SNR>139_VimCloseCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:88
Called 3 times
Total time:   0.417721464
 Self time:   0.005358929

count     total (s)      self (s)
    3                 0.000225483     let l:job = ch_getjob(a:channel)
    3   0.000301135   0.000131829     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
    3                 0.000081428     let l:info = get(s:job_map, l:job_id, {})
                                  
    3                 0.000038463     if empty(l:info)
                                          return
    3                 0.000011151     endif
                                  
                                      " job_status() can trigger the exit handler.
                                      " The channel can close before the job has exited.
    3   0.413730433   0.001537204     if job_status(l:job) is# 'dead'
    3                 0.000028650         try
    3                 0.000065626             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                                  " We have to remove the callback, so we don't call it twice.
                                                  call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
    3                 0.000008611             endif
    3                 0.002900191         finally
                                              " Automatically forget about the job after it's done.
    3                 0.000093966             if has_key(s:job_map, l:job_id)
                                                  call remove(s:job_map, l:job_id)
    3                 0.000008512             endif
    3                 0.000009275         endtry
    3                 0.000005351     endif

FUNCTION  <SNR>139_VimErrorCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:78
Called 8 times
Total time:   0.049246388
 Self time:   0.005353740

count     total (s)      self (s)
    8                 0.000219221     let l:job = ch_getjob(a:channel)
    8   0.003741782   0.003401444     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                                  
                                      " Only call the callbacks for jobs which are valid.
    8                 0.000191720     if l:job_id > 0 && has_key(s:job_map, l:job_id)
    8   0.044933995   0.001381685         call ale#util#GetFunction(s:job_map[l:job_id].err_cb)(l:job_id, a:data)
    8                 0.000041827     endif

FUNCTION  <SNR>114_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 156 times
Total time:   0.015767042
 Self time:   0.015767042

count     total (s)      self (s)
  156                 0.011663285     if index(a:list, a:name) == -1
  148                 0.002289176       call add(a:list, a:name)
  148                 0.000797438       return 1
    8                 0.000018101     else
    8                 0.000061027       if &vbs
                                          echomsg printf("airline: group: %s already done, skipping", a:name)
    8                 0.000019738       endif
    8                 0.000034315       return 0
                                      endif

FUNCTION  ale#lsp_linter#HandleLSPResponse()
    Defined: ~/.vim/plugged/ale/autoload/ale/lsp_linter.vim:225
Called 2 times
Total time:   0.000945772
 Self time:   0.000945772

count     total (s)      self (s)
    2                 0.000031038     let l:method = get(a:response, 'method', '')
                                  
    2                 0.000035851     if get(a:response, 'jsonrpc', '') is# '2.0' && has_key(a:response, 'error')
                                          let l:linter = get(s:lsp_linter_map, a:conn_id, {})
                                  
                                          call s:HandleLSPErrorMessage(l:linter, a:response)
    2                 0.000019326     elseif l:method is# 'textDocument/publishDiagnostics'
                                          let l:uri = a:response.params.uri
                                          let l:diagnostics = a:response.params.diagnostics
                                  
                                          call ale#lsp_linter#HandleLSPDiagnostics(a:conn_id, l:uri, l:diagnostics)
    2                 0.000032877     elseif has_key(s:diagnostic_uri_map, get(a:response, 'id'))
                                          let l:uri = remove(s:diagnostic_uri_map, a:response.id)
                                          let l:diagnostics = a:response.result.kind is# 'unchanged'   ? 'unchanged'   : a:response.result.items
                                  
                                          call ale#lsp_linter#HandleLSPDiagnostics(a:conn_id, l:uri, l:diagnostics)
    2                 0.000014550     elseif l:method is# 'window/showMessage'
                                          call ale#lsp_window#HandleShowMessage(   s:lsp_linter_map[a:conn_id].name,   g:ale_lsp_show_message_format,   a:response.params)
    2                 0.000031326     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'semanticDiag'
                                          call s:HandleTSServerDiagnostics(a:response, 'semantic')
    2                 0.000034189     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'syntaxDiag'
                                          call s:HandleTSServerDiagnostics(a:response, 'syntax')
    2                 0.000038501     elseif get(a:response, 'type', '') is# 'event'&& get(a:response, 'event', '') is# 'suggestionDiag'&& get(g:, 'ale_lsp_suggestions')
                                          call s:HandleTSServerDiagnostics(a:response, 'suggestion')
    2                 0.000006575     endif

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:74
Called 1 time
Total time:   0.001817790
 Self time:   0.000219558

count     total (s)      self (s)
    1                 0.000012838     let l:buffer = bufnr('')
                                  
    1                 0.000006850     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                          return
    1                 0.000001887     endif
                                  
                                      " Only echo the warnings in normal mode, otherwise we will get problems.
    1                 0.000010638     if mode(1) isnot# 'n'
                                          return
    1                 0.000001887     endif
                                  
    1   0.000614422   0.000013851     if ale#ShouldDoNothing(l:buffer)
                                          return
    1                 0.000001713     endif
                                  
    1   0.001029974   0.000032313     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                                  
    1                 0.000005412     if g:ale_echo_cursor
    1                 0.000008563         if !empty(l:loc)
                                              let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                              let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                  
                                              call ale#cursor#TruncatedEcho(l:msg)
                                              let l:info.echoed = 1
    1                 0.000009725         elseif get(l:info, 'echoed')
                                              " We'll only clear the echoed message when moving off errors once,
                                              " so we don't continually clear the echo line.
                                              "
                                              " no-custom-checks
                                              echo
                                              let l:info.echoed = 0
    1                 0.000002250         endif
    1                 0.000001625     endif
                                  
    1                 0.000004313     if g:ale_cursor_detail
                                          if !empty(l:loc)
                                              call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                          else
                                              call ale#preview#CloseIfTypeMatches('ale-preview')
                                          endif
    1                 0.000001675     endif

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:231
Called 5 times
Total time:   0.023734000
 Self time:   0.000508782

count     total (s)      self (s)
    5   0.000325837   0.000172107     let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    5                 0.000093365     let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    5   0.023288208   0.000216720     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:253
Called 77 times
Total time:   0.052255390
 Self time:   0.052255390

count     total (s)      self (s)
   77                 0.000721864     let l:msg = a:format_string
   77                 0.003684840     let l:severity = g:ale_echo_msg_warning_str
   77                 0.004192899     let l:code = get(a:item, 'code', '')
   77                 0.002437562     let l:type = get(a:item, 'type', 'E')
   77                 0.001077459     let l:linter_name = get(a:item, 'linter_name', '')
   77                 0.001134553     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                                  
   77                 0.002811700     if l:type is# 'E'
                                          let l:severity = g:ale_echo_msg_error_str
   77                 0.000629307     elseif l:type is# 'I'
                                          let l:severity = g:ale_echo_msg_info_str
   77                 0.000187313     endif
                                  
                                      " Replace special markers with certain information.
                                      " \=l:variable is used to avoid escaping issues.
   77                 0.010306433     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
   77                 0.006021594     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   77                 0.002015974     let l:msg = substitute(l:msg, '\V%type%', '\=l:type', 'g')
   77                 0.004822268     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                      " Replace %s with the text.
   77                 0.002035786     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                      " Windows may insert carriage return line endings (^M), strip these characters.
   77                 0.004030400     let l:msg = substitute(l:msg, '\r', '', 'g')
                                  
   77                 0.000569872     return l:msg

FUNCTION  airline#parts#executable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:210
Called 9 times
Total time:   0.006059666
 Self time:   0.006059666

count     total (s)      self (s)
    9                 0.005858747   if exists("*getfperm") && getfperm(bufname('%')) =~ 'x'
                                      return g:airline_symbols.executable
    9                 0.000029438   else
    9                 0.000035963     return ''
                                    endif

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:442
Called 3 times
Total time:   0.097366435
 Self time:   0.002508817

count     total (s)      self (s)
    3                 0.000059441     if !bufexists(str2nr(a:buffer))
                                          " Stop immediately when attempting to set signs for a buffer which
                                          " does not exist.
                                          return
    3                 0.000006087     endif
                                  
                                      " Find the current markers
    3   0.008009162   0.000110331     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                                  
                                      " Update the line numbers for items from before which may have moved.
    3   0.023031488   0.000292775     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                                  
                                      " Group items after updating the line numbers.
    3   0.005792819   0.001212842     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                                  
                                      " Build a map of current and new signs, with the lines as the keys.
    3   0.040851300   0.000182432     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                                  
    3   0.019090258   0.000119029     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                                  
                                      " Change the sign column color if the option is on.
    3                 0.000032764     if g:ale_change_sign_column_color && !empty(a:loclist)
                                          highlight clear SignColumn
                                          highlight link SignColumn ALESignColumnWithErrors
    3                 0.000005224     endif
                                  
   10                 0.000055889     for l:command in l:command_list
    7                 0.000191482         silent! execute l:command
   10                 0.000030114     endfor
                                  
                                      " Reset the sign column color when there are no more errors.
    3                 0.000027138     if g:ale_change_sign_column_color && empty(a:loclist)
                                          highlight clear SignColumn
                                          highlight link SignColumn ALESignColumnWithoutErrors
    3                 0.000005050     endif

FUNCTION  ale#virtualtext#GetColumnPadding()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:128
Called 29 times
Total time:   0.015997659
 Self time:   0.011885152

count     total (s)      self (s)
   29   0.004256351   0.001732987     let l:mincol = ale#Var(a:buffer, 'virtualtext_column')
   29   0.002139577   0.000550434     let l:maxcol = ale#Var(a:buffer, 'virtualtext_maxcolumn')
   29                 0.002087175     let l:win = bufwinnr(a:buffer)
                                  
   29                 0.001876378     if l:mincol[len(l:mincol)-1] is# '%'
                                          let l:mincol = (winwidth(l:win) * l:mincol) / 100
   29                 0.000104456     endif
                                  
   29                 0.000467604     if l:maxcol[len(l:maxcol)-1] is# '%'
                                          let l:maxcol = (winwidth(l:win) * l:maxcol) / 100
   29                 0.000092313     endif
                                  
                                      " Calculate padding for virtualtext alignment
   29                 0.000275304     if l:mincol > 0 || l:maxcol > 0
                                          let l:line_width = strdisplaywidth(getline(a:line))
                                  
                                          if l:line_width < l:mincol
                                              return l:mincol - l:line_width
                                          elseif l:maxcol > 0 && l:line_width >= l:maxcol
                                              " Stop processing if virtualtext would start beyond maxcol
                                              return -1
                                          endif
   29                 0.000049891     endif
                                  
                                      " no padding.
   29                 0.000139892     return 0

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:21
Called 4 times
Total time:   0.000210808
 Self time:   0.000210808

count     total (s)      self (s)
    4                 0.000123792     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                                  
    4                 0.000068765     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:39
Called 3 times
Total time:   0.000096067
 Self time:   0.000096067

count     total (s)      self (s)
    3                 0.000040238     if has_key(s:buffer_data, a:buffer)
    3                 0.000037864         let s:buffer_data[a:buffer].cwd = v:null
    3                 0.000008951     endif

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:205
Called 3 times
Total time:   0.007525568
 Self time:   0.007525568

count     total (s)      self (s)
    3                 0.000227646     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale_signs' : '' })[0].signs
    3                 0.000023538     let l:result = []
    3                 0.000023051     let l:is_dummy_sign_set = 0
                                  
   31                 0.000187896     for l:sign in l:signs
   28                 0.000245469         if l:sign['name'] is# 'ALEDummySign'
                                              let l:is_dummy_sign_set = 1
   28                 0.000089607         else
   28                 0.000969212             call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
   28                 0.000226763         endif
   31                 0.000078189     endfor
                                  
    3                 0.000033226     return [l:is_dummy_sign_set, l:result]

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 272 times
Total time:   0.487136684
 Self time:   0.164186148

count     total (s)      self (s)
                                      " only check for the cterm reverse attribute
                                      " TODO: do we need to check all modes (gui, term, as well)?
  272                 0.010641814     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  272                 0.013533318     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                        let res = s:hl_groups[a:group]
                                        return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  272                 0.008890493     else
  272   0.075830660   0.012736760       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  272   0.097685943   0.017223395       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  272   0.104733950   0.006468302       let guifg = s:get_syn(a:group, 'fg', 'gui')
  272   0.086384807   0.012370779       let guibg = s:get_syn(a:group, 'bg', 'gui')
  272                 0.020710274       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  272                 0.001626196       if reverse
                                          let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  272                 0.000955218       else
  272   0.014570956   0.007456544         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  272                 0.000915593       endif
  272                 0.000495964     endif
  272                 0.003786378     let s:hl_groups[a:group] = res
  272                 0.001499080     return res

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:44
Called 126 times
Total time:   0.007048157
 Self time:   0.006604527

count     total (s)      self (s)
  126   0.003184058   0.002740428   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                      return ''
  126                 0.000286534   endif
  126                 0.002617818   return a:text

FUNCTION  <SNR>139_VimOutputCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/job.vim:68
Called 14 times
Total time:   0.012574487
 Self time:   0.001652909

count     total (s)      self (s)
   14                 0.000324035     let l:job = ch_getjob(a:channel)
   14   0.000899684   0.000403954     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                                  
                                      " Only call the callbacks for jobs which are valid.
   14                 0.000248511     if l:job_id > 0 && has_key(s:job_map, l:job_id)
   14   0.010958807   0.000532959         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
   14                 0.000043738     endif

FUNCTION  186()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 2 times
Total time:   0.000036326
 Self time:   0.000036326

count     total (s)      self (s)
    2                 0.000023838     return 'NERD_tree_'

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:119
Called 14 times
Total time:   0.014152769
 Self time:   0.000516044

count     total (s)      self (s)
                                      " The Dictionary is copied here before exposing it to other plugins.
   14   0.014087054   0.000450329     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>102_airline_lsp_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:11
Called 18 times
Total time:   0.000269297
 Self time:   0.000269297

count     total (s)      self (s)
   18                 0.000223471   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#util#LocItemCompareWithText()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:209
Called 147 times
Total time:   0.313125970
 Self time:   0.024096312

count     total (s)      self (s)
  147   0.305177849   0.016148191     let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                                  
  147                 0.002656044     if l:cmp_value
  123                 0.004002534         return l:cmp_value
   24                 0.000048776     endif
                                  
   24                 0.000239036     if a:left.text < a:right.text
   19                 0.000093217         return -1
    5                 0.000107628     endif
                                  
    5                 0.000040189     if a:left.text > a:right.text
    1                 0.000005076         return 1
    4                 0.000007864     endif
                                  
    4                 0.000014112     return 0

FUNCTION  <SNR>206_PriorityCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:154
Called 4 times
Total time:   0.000087154
 Self time:   0.000087154

count     total (s)      self (s)
    4                 0.000028575     if s:supports_sign_groups
    4                 0.000046201         return ' priority=' . g:ale_sign_priority . ' '
                                      else
                                          return ''
                                      endif

FUNCTION  lsp#get_buffer_diagnostics_counts()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:1277
Called 18 times
Total time:   0.020197719
 Self time:   0.000735125

count     total (s)      self (s)
   18   0.020155196   0.000692602     return lsp#internal#diagnostics#state#_get_diagnostics_count_for_buffer(bufnr('%'))

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:622
Called 2 times
Total time:   0.000125467
 Self time:   0.000125467

count     total (s)      self (s)
    2                 0.000016588   let res = []
    2                 0.000037451   let list_all = get(a:, 1, 0)
    2                 0.000013225   if s:is_vim
    2                 0.000046864     return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(list_all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                    else
                                      let res = []
                                      for id in nvim_list_wins()
                                        let config = nvim_win_get_config(id)
                                        if empty(config) || empty(config['relative'])
                                          continue
                                        endif
                                        " ignore border & button window & others
                                        if list_all == 0 && !getwinvar(id, 'float', 0)
                                          continue
                                        endif
                                        call add(res, id)
                                      endfor
                                      return res
                                    endif
                                    return []

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:262
Called 4 times
Total time:   1.006533275
 Self time:   0.175542425

count     total (s)      self (s)
    4                 0.000114717     let bufnr = a:0 ? a:1 : ''
    4                 0.000095141     let p = g:airline#themes#{g:airline_theme}#palette
                                  
                                      " draw the base mode, followed by any overrides
    4                 0.000243747     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4                 0.000099429     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    4                 0.000051527     let airline_grouplist = []
    4                 0.000101391     let buffers_in_tabpage = sort(tabpagebuflist())
    4                 0.000085304     if exists("*uniq")
    4                 0.000071915       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    4                 0.000021951     endif
                                      " mapped might be something like ['normal', 'normal_modified']
                                      " if a group is in both modes available, only define the second
                                      " that is how this was done previously overwrite the previous definition
    8                 0.000109681     for mode in reverse(mapped)
    4                 0.000163119       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4                 0.000088928         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   96                 0.001066265         for kvp in items(dict)
   92                 0.001512146           let mode_colors = kvp[1]
   92                 0.001250232           let name = kvp[0]
   92                 0.004452805           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                              let name = 'airline_c'.bufnr
   92                 0.000227818           endif
                                            " do not re-create highlighting for buffers that are no longer visible
                                            " in the current tabpage
   92                 0.009542229           if name =~# 'airline_c\d\+'
                                              let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                              if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                                continue
                                              endif
   92                 0.006206584           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                              " group will be redefined below at exec_separator
                                              " or is not needed for tabline with '_inactive' suffix
                                              " since active flag is 1 for builder)
   40                 0.000371960             continue
   52                 0.000106888           endif
   52   0.012533865   0.001328688           if s:group_not_done(airline_grouplist, name.suffix)
   44   0.157254448   0.001073508             call airline#highlighter#exec(name.suffix, mode_colors)
   52                 0.000144920           endif
                                  
   52                 0.000893600           if !has_key(p, 'accents')
                                              " work around a broken installation
                                              " shouldn't actually happen, p should always contain accents
                                              continue
   52                 0.000110184           endif
                                  
  156                 0.001359511           for accent in keys(s:accents)
  104                 0.001320259             if !has_key(p.accents, accent)
                                                continue
  104                 0.000206946             endif
  104                 0.001793562             let colors = copy(mode_colors)
  104                 0.009754695             if p.accents[accent][0] != ''
   52                 0.000858130               let colors[0] = p.accents[accent][0]
  104                 0.000341375             endif
  104                 0.001265205             if p.accents[accent][2] != ''
   52                 0.000766103               let colors[2] = p.accents[accent][2]
  104                 0.000297720             endif
  104                 0.001008534             if len(colors) >= 5
  104                 0.001895642               let colors[4] = get(p.accents[accent], 4, '')
                                              else
                                                call add(colors, get(p.accents[accent], 4, ''))
  104                 0.000289534             endif
  104   0.007300189   0.002738324             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  104   0.372301571   0.002714396               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  104                 0.000297302             endif
  156                 0.006454676           endfor
   56                 0.000148117         endfor
                                  
    4                 0.000049939         if empty(s:separators)
                                            " nothing to be done
                                            continue
    4                 0.000007563         endif
                                          " TODO: optimize this
   44                 0.008557310         for sep in items(s:separators)
                                            " we cannot check, that the group already exists, else the separators
                                            " might not be correctly defined. But perhaps we can skip above groups
                                            " that match the '_to_' name, because they would be redefined here...
   40   0.297769845   0.008314152           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   44                 0.004237572         endfor
    4                 0.000007838       endif
    8                 0.000042979     endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:79
Called 6 times
Total time:   0.000328812
 Self time:   0.000328812

count     total (s)      self (s)
    6                 0.000191182   if empty(s:client) || s:client['running'] == 0
                                      return 0
    6                 0.000020400   endif
    6                 0.000037214   return 1

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:198
Called 9 times
Total time:   0.000846645
 Self time:   0.000846645

count     total (s)      self (s)
    9                 0.000157182   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    9                 0.000097314   let bomb     = &bomb ? '[BOM]' : ''
    9                 0.000099354   let noeolf   = &eol ? '' : '[!EOL]'
    9                 0.000180719   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    9                 0.000122766   if expected is# &fenc.bomb.noeolf.ff
                                      return ''
    9                 0.000020365   else
    9                 0.000077979     return &fenc.bomb.noeolf.ff
                                    endif

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:194
Called 110 times
Total time:   0.009224256
 Self time:   0.009224256

count     total (s)      self (s)
  110                 0.002988838     let l:full_name = 'ale_' . a:variable_name
  110                 0.003413012     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                                  
  110                 0.001979743     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>104_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:187
Called 2 times
Total time:   0.000089578
 Self time:   0.000089578

count     total (s)      self (s)
    2                 0.000027526   if !exists('#airline')
                                      " airline disabled
                                      return
    2                 0.000003762   endif
    2                 0.000032601   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2                 0.000007175     return
                                    endif
                                    unlet! b:airline_whitespace_check
                                    if get(g:, 'airline_skip_empty_sections', 0)
                                      exe ':AirlineRefresh!'
                                    endif
                                    let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>114_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 156 times
Total time:   0.011255502
 Self time:   0.011255502

count     total (s)      self (s)
  156                 0.002895961     if !hlexists(a:group)
                                        return 0
  156                 0.003289291     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                        return 0
  156                 0.000357303     endif
  156                 0.000543508     return 1

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:138
Called 9 times
Total time:   0.001009325
 Self time:   0.001009325

count     total (s)      self (s)
    9                 0.000281047   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
    9                 0.000691286   return match(a:name, pat) > -1

FUNCTION  <SNR>146_on_stderr()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp.vim:898
Called 1 time
Total time:   0.000148381
 Self time:   0.000040027

count     total (s)      self (s)
    1   0.000145792   0.000037438     call lsp#log_verbose('<---(stderr)', a:id, a:server_name, a:data)

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:187
Called 6 times
Total time:   0.017951719
 Self time:   0.000941998

count     total (s)      self (s)
    6   0.000485279   0.000156467   if !coc#rpc#ready()
                                      return ''
    6                 0.000018838   endif
    6   0.017311196   0.000630287   call s:client['notify'](a:method, a:args)
    6                 0.000055402   return ''

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 63 times
Total time:   0.011752182
 Self time:   0.011752182

count     total (s)      self (s)
   63                 0.000967679   let nr = get(a:000, 0, 0)
                                    " When statusline is on top, or using global statusline for Neovim
                                    " always return the number of columns
   63                 0.009159339   if get(g:, 'airline_statusline_ontop', 0) || &laststatus > 2
                                      return &columns
   63                 0.000159893   else
   63                 0.000671474     return winwidth(nr)
                                    endif

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:301
Called 8 times
Total time:   0.009638857
 Self time:   0.009638857

count     total (s)      self (s)
    8                 0.009411899   if get(g:, 'airline_statusline_ontop', 0)
                                      call airline#extensions#tabline#redraw()
    8                 0.000045039   endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:232
Called 1 time
Total time:   0.000881882
 Self time:   0.000881882

count     total (s)      self (s)
    1                 0.000008601     let l:min = 0
    1                 0.000012463     let l:max = len(a:loclist) - 1
                                  
    5                 0.000018100     while 1
    5                 0.000028563         if l:max < l:min
    1                 0.000004537             return -1
    4                 0.000007850         endif
                                  
    4                 0.000035552         let l:mid = (l:min + l:max) / 2
    4                 0.000048965         let l:item = a:loclist[l:mid]
                                  
                                          " Binary search for equal buffers, equal lines, then near columns.
    4                 0.000029539         if l:item.bufnr < a:buffer
    1                 0.000007588             let l:min = l:mid + 1
    3                 0.000020349         elseif l:item.bufnr > a:buffer
                                              let l:max = l:mid - 1
    3                 0.000018551         elseif l:item.lnum < a:line
                                              let l:min = l:mid + 1
    3                 0.000018189         elseif l:item.lnum > a:line
    3                 0.000022713             let l:max = l:mid - 1
                                          else
                                              " This part is a small sequential search.
                                              let l:index = l:mid
                                  
                                              " Search backwards to find the first problem on the line.
                                              while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                                  let l:index -= 1
                                              endwhile
                                  
                                              " Find the last problem on or before this column.
                                              while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                                  let l:index += 1
                                              endwhile
                                  
                                              " Scan forwards to find the last item on the column for the item
                                              " we found, which will have the most serious problem.
                                              let l:item_column = a:loclist[l:index].col
                                  
                                              while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                                  let l:index += 1
                                              endwhile
                                  
                                              return l:index
    4                 0.000007988         endif
    4                 0.000008562     endwhile

FUNCTION  ale#virtualtext#Clear()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:83
Called 3 times
Total time:   0.000731751
 Self time:   0.000731751

count     total (s)      self (s)
    3                 0.000113004     if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                          return
    3                 0.000006075     endif
                                  
    3                 0.000051589     if has('nvim')
                                          call nvim_buf_clear_namespace(a:buffer, s:ns_id, 0, -1)
    3                 0.000010613     else
    3                 0.000019088         if s:emulate_virt && s:last_virt != -1
                                              call prop_remove({'type': 'ale'})
                                              call popup_close(s:last_virt)
                                              let s:last_virt = -1
    3                 0.000033664         elseif !empty(s:hl_list)
    3                 0.000273923             call prop_remove({   'types': s:hl_list,   'all': 1,   'bufnr': a:buffer,})
    3                 0.000010200         endif
    3                 0.000005275     endif

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:179
Called 9 times
Total time:   0.001750647
 Self time:   0.000741322

count     total (s)      self (s)
                                    " only consider regular buffers (e.g. ones that represent actual files,
                                    " but not special ones like e.g. NERDTree)
    9   0.001375287   0.000365962   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                      return ''
    9                 0.000021613   endif
    9                 0.000105254   if &readonly && !filereadable(bufname('%'))
                                      return '[noperm]'
    9                 0.000019564   else
    9                 0.000064202     return &readonly ? g:airline_symbols.readonly : ''
                                    endif

FUNCTION  coc#api#Buf_flush()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/api.vim:1056
Called 2 times
Total time:   0.001405213
 Self time:   0.001405213

count     total (s)      self (s)
    2                 0.000046765   if type(id) == v:t_number && has_key(listener_map, id)
    2                 0.000008912     listener_flush(id)
    2                 0.000000163   endif

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:129
Called 142 times
Total time:   0.035772881
 Self time:   0.035772881

count     total (s)      self (s)
  142                 0.015691496     if a:item.type is# 'I'
                                          return g:ale#util#info_priority
  142                 0.001935169     endif
                                  
  142                 0.000951262     if a:item.type is# 'W'
  142                 0.007528700         if get(a:item, 'sub_type', '') is# 'style'
                                              return g:ale#util#style_warning_priority
  142                 0.000452564         endif
                                  
  142                 0.000721142         return g:ale#util#warning_priority
                                      endif
                                  
                                      if get(a:item, 'sub_type', '') is# 'style'
                                          return g:ale#util#style_error_priority
                                      endif
                                  
                                      return g:ale#util#error_priority

FUNCTION  <SNR>147_debounceTimeTimerCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:586
Called 4 times
Total time:   0.002752323
 Self time:   0.000348637

count     total (s)      self (s)
    4   0.002726023   0.000322337     call a:data['sink'](1, a:d)

FUNCTION  airline#extensions#lsp#progress()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:65
Called 9 times
Total time:   0.003096386
 Self time:   0.002772276

count     total (s)      self (s)
    9                 0.000120455   if get(w:, 'airline_active', 0)
    9                 0.002199104     if exists('*lsp#get_progress')
    9   0.000541907   0.000217797       let s:lsp_progress = lsp#get_progress()
                                  
    9                 0.000152093       if len(s:lsp_progress) == 0 | return '' | endif
                                  
                                        " show only most new progress
                                        let s:lsp_progress = s:lsp_progress[0]
                                        if s:lsp_progress['message'] !=# ''
                                          let percent = ''
                                          if has_key(s:lsp_progress, 'percentage') && s:lsp_progress['percentage'] >= 0
                                            let percent = ' ' . string(s:lsp_progress['percentage']) . '%'
                                          endif
                                          let s:title = s:lsp_progress['title']
                                          let message = airline#util#shorten(s:lsp_progress['message'] . percent, 91, 9)
                                          return s:lsp_progress['server'] . ': ' . s:title . ' ' . message
                                        endif
                                      endif
                                    endif
                                    return ''

FUNCTION  airline#extensions#lsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/lsp.vim:60
Called 9 times
Total time:   0.040272376
 Self time:   0.000193418

count     total (s)      self (s)
    9   0.040253379   0.000174421   return airline#extensions#lsp#get('error')

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:22
Called 3 times
Total time:   0.000114792
 Self time:   0.000114792

count     total (s)      self (s)
    3                 0.000052077     if !has_key(s:buffer_data, a:buffer)
    1                 0.000023138         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
    3                 0.000008275     endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:226
Called 192 times
Total time:   0.683395054
 Self time:   0.219972998

count     total (s)      self (s)
  192                 0.001928451     if pumvisible()
                                        return
  192                 0.000387902     endif
  192                 0.001478683     let colors = a:colors
  192                 0.001927613     if len(colors) == 4
   40                 0.000505669       call add(colors, '')
  192                 0.000533088     endif
                                      " colors should always be string values
  192                 0.049177753     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  192                 0.001388959     if s:is_win32term
                                        let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                        let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  192                 0.000665203     endif
  192   0.358355512   0.003933589     let old_hi = airline#highlighter#get_highlight(a:group)
  192                 0.021944101     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  192   0.050170595   0.012610270     let colors = s:CheckDefined(colors)
  192   0.023693395   0.012437893     if old_hi != new_hi || !s:hl_group_exists(a:group)
   36   0.066521182   0.006336876       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   36                 0.000158670       try
   36                 0.009829938         exe cmd
                                        catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                          let group=matchstr(v:exception, '\w\+\ze=')
                                          let color=matchstr(v:exception, '=\zs\w\+')
                                          let cmd=substitute(cmd, color, 'grey', 'g')
                                          exe cmd
                                          call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                        catch
                                          call airline#util#warning('Error when running command: '. cmd)
   36                 0.000153735       endtry
   36                 0.000434865       if has_key(s:hl_groups, a:group)
   36                 0.000394553         let s:hl_groups[a:group] = colors
   36                 0.000095403       endif
  192                 0.000380710     endif

FUNCTION  ale#util#LocItemCompare()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:151
Called 260 times
Total time:   0.315209298
 Self time:   0.299362719

count     total (s)      self (s)
  260                 0.018692019     if a:left.bufnr < a:right.bufnr
   51                 0.000255363         return -1
  209                 0.000475276     endif
                                  
  209                 0.001640334     if a:left.bufnr > a:right.bufnr
    9                 0.000039729         return 1
  200                 0.000436618     endif
                                  
  200                 0.017358382     if a:left.bufnr == -1
   14                 0.000117918         if a:left.filename < a:right.filename
   13                 0.000060002             return -1
    1                 0.000002075         endif
                                  
    1                 0.000006901         if a:left.filename > a:right.filename
    1                 0.000004650             return 1
                                          endif
  186                 0.000406992     endif
                                  
  186                 0.001400911     if a:left.lnum < a:right.lnum
  135                 0.000891333         return -1
   51                 0.000103143     endif
                                  
   51                 0.000309749     if a:left.lnum > a:right.lnum
   12                 0.000051602         return 1
   39                 0.000090505     endif
                                  
   39                 0.000262256     if a:left.col < a:right.col
                                          return -1
   39                 0.000086754     endif
                                  
   39                 0.000263045     if a:left.col > a:right.col
                                          return 1
   39                 0.000075565     endif
                                  
                                      " When either of the items lacks a problem type, then the two items should
                                      " be considered equal. This is important for loclist jumping.
   39                 0.000723885     if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                          return 0
   39                 0.000086794     endif
                                  
   39   0.004853810   0.002744546     let l:left_priority = ale#util#GetItemPriority(a:left)
   39   0.015278549   0.001541234     let l:right_priority = ale#util#GetItemPriority(a:right)
                                  
   39                 0.000311850     if l:left_priority < l:right_priority
                                          return -1
   39                 0.000084929     endif
                                  
   39                 0.002349324     if l:left_priority > l:right_priority
                                          return 1
   39                 0.000118029     endif
                                  
   39                 0.000178469     return 0

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:49
Called 3 times
Total time:   0.001457278
 Self time:   0.000159020

count     total (s)      self (s)
    3   0.001385962   0.000087704     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                                  
                                      " If we find a match, then set the code and status.
    3                 0.000031626     let l:obj.exit_code = a:exit_code
    3                 0.000022714     let l:obj.status = 'finished'

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:48
Called 40 times
Total time:   0.001406775
 Self time:   0.001406775

count     total (s)      self (s)
   40                 0.000609796     if a:line >= a:end_line
                                          " For single lines, just return the one position.
   40                 0.000611069         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                      endif
                                  
                                      " Get positions from the first line at the first column, up to a large
                                      " integer for highlighting up to the end of the line, followed by
                                      " the lines in-between, for highlighting entire lines, and
                                      " a highlight for the last line, up to the end column.
                                      let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                                  
                                      return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>187_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:67
Called 2 times
Total time:   0.000069316
 Self time:   0.000069316

count     total (s)      self (s)
    2                 0.000020002     if s:cursor_timer != -1
                                          call timer_stop(s:cursor_timer)
                                          let s:cursor_timer = -1
    2                 0.000004950     endif

FUNCTION  <SNR>134_HandleExit()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:151
Called 3 times
Total time:   0.400854949
 Self time:   0.005190211

count     total (s)      self (s)
    3                 0.000059364     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                                  
    3                 0.000030651     if empty(l:buffer_info)
                                          return
    3                 0.000005913     endif
                                  
    3                 0.000025951     let l:linter = a:job_info.linter
    3                 0.000026576     let l:executable = a:job_info.executable
                                  
                                      " Remove this job from the list.
    3   0.004391782   0.004229289     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                                  
                                      " Stop here if we land in the handle for a job completing if we're in
                                      " a sandbox.
    3   0.000255371   0.000052626     if ale#util#InSandbox()
                                          return
    3                 0.000005588     endif
                                  
    3                 0.000113630     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                          call remove(a:output, -1)
    3                 0.000007975     endif
                                  
    3                 0.000006250     try
    3   0.048314079   0.000143166         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                      " Handle the function being unknown, or being deleted.
                                      catch /E700/
                                          let l:loclist = []
    3                 0.000013126     endtry
                                  
    3                 0.000044851     if type(l:loclist) isnot# v:t_list
                                          " we only expect the list type; don't pass anything else down to
                                          " `ale#engine#HandleLoclist` since it won't understand it
                                          let l:loclist = []
    3                 0.000007100     endif
                                  
    3   0.347364033   0.000235446     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>206_GroupCmd()
    Defined: ~/.vim/plugged/ale/autoload/ale/sign.vim:162
Called 7 times
Total time:   0.000321562
 Self time:   0.000321562

count     total (s)      self (s)
    7                 0.000245771     if s:supports_sign_groups
    7                 0.000046316         return ' group=ale_signs '
                                      else
                                          return ' '
                                      endif

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:207
Called 3 times
Total time:   0.000482379
 Self time:   0.000298348

count     total (s)      self (s)
    3                 0.000088291     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                          " Update lists immediately if running a test synchronously, or if the
                                          " buffer was saved.
                                          "
                                          " The lists need to be updated immediately when saving a buffer so
                                          " that we can reliably close window automatically, if so configured.
                                          call s:SetListsImpl(-1, a:buffer, a:loclist)
    3                 0.000011763     else
    3   0.000301636   0.000117605         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    3                 0.000008800     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:290
Called 8 times
Total time:   0.004624303
 Self time:   0.000485253

count     total (s)      self (s)
    8                 0.000036038     try
    8   0.004351792   0.000212742         let &l:equalprg=&l:equalprg
                                      catch /E48/
                                          " E48 is the sandbox error.
                                          return 1
    8                 0.000038925     endtry
                                  
    8                 0.000032978     return 0

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:61
Called 9 times
Total time:   0.000310985
 Self time:   0.000310985

count     total (s)      self (s)
    9                 0.000277211   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:34
Called 5 times
Total time:   0.000646422
 Self time:   0.000646422

count     total (s)      self (s)
    5                 0.000102892     let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
    5                 0.000082366     let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                                  
    5                 0.000070014     let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
    5                 0.000129780     let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                                  
    5                 0.000135568     if getbufvar(a:bufnr, '&modified') == 1
                                        let _ .= g:airline_symbols.modified
    5                 0.000012663     endif
    5                 0.000031677     return _

FUNCTION  lsp#internal#diagnostics#first_line#get_first_error_line()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/first_line.vim:6
Called 9 times
Total time:   0.023291983
 Self time:   0.013118068

count     total (s)      self (s)
    9                 0.000181982     let l:bufnr = get(a:options, 'bufnr', bufnr('%'))
                                  
    9   0.000303335   0.000133778     if !lsp#internal#diagnostics#state#_is_enabled_for_buffer(l:bufnr)
                                          return v:null
    9                 0.000021213     endif
                                  
    9   0.007486093   0.000154218     let l:uri = lsp#utils#get_buffer_uri(l:bufnr)
    9   0.002625220   0.000194559     let l:diagnostics_by_server = lsp#internal#diagnostics#state#_get_all_diagnostics_grouped_by_server_for_uri(l:uri)
                                  
    9                 0.000100104     let l:first_error_line = v:null
   18                 0.004303818     for l:diagnostics_response in values(l:diagnostics_by_server)
   45   0.004803350   0.004561528         for l:item in lsp#utils#iteratable(l:diagnostics_response['params']['diagnostics'])
   36                 0.000525840             let l:severity = get(l:item, 'severity', 1)
   36                 0.000463806             if l:severity ==# 1 && (l:first_error_line ==# v:null || l:first_error_line ># l:item['range']['start']['line'])
                                                  let l:first_error_line = l:item['range']['start']['line']
   36                 0.000102904             endif
   45                 0.000115442         endfor
   18                 0.000046313     endfor
    9                 0.000109717     return l:first_error_line ==# v:null ? v:null : l:first_error_line + 1

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:288
Called 3 times
Total time:   0.032971505
 Self time:   0.026733509

count     total (s)      self (s)
    3   0.000513630   0.000065477     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                                  
    3                 0.000028076     if !empty(l:mappings)
                                          " We need to apply reverse filename mapping here.
                                          let l:mappings = ale#filename_mapping#Invert(l:mappings)
    3                 0.000007813     endif
                                  
    3                 0.000021700     let l:bufnr_map = {}
    3                 0.000020600     let l:new_loclist = []
                                  
                                      " Some errors have line numbers beyond the end of the file,
                                      " so we need to adjust them so they set the error at the last line
                                      " of the file instead.
    3   0.000461918   0.000062829     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                                  
   13                 0.002923254     for l:old_item in a:loclist
                                          " Copy the loclist item with some default values and corrections.
                                          "
                                          " line and column numbers will be converted to numbers.
                                          " The buffer will default to the buffer being checked.
                                          " The vcol setting will default to 0, a byte index.
                                          " The error type will default to 'E' for errors.
                                          " The error number will default to -1.
                                          "
                                          " The line number and text are the only required keys.
                                          "
                                          " The linter_name will be set on the errors so it can be used in
                                          " output, filtering, etc..
   10                 0.000691200         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                                  
   10                 0.000062077         if a:from_other_source
                                              let l:item.from_other_source = 1
   10                 0.000025016         endif
                                  
   10                 0.000094778         if has_key(l:old_item, 'code')
                                              let l:item.code = l:old_item.code
   10                 0.000021788         endif
                                  
   10                 0.000123854         let l:old_name = get(l:old_item, 'filename', '')
                                  
                                          " Map parsed from output to local filesystem files.
   10                 0.000244809         if !empty(l:old_name) && !empty(l:mappings)
                                              let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
   10                 0.000024152         endif
                                  
   10   0.005402016   0.000258133         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                              " Use the filename given.
                                              " Temporary files are assumed to be for this buffer,
                                              " and the filename is not included then, because it looks bad
                                              " in the loclist window.
   10                 0.000095528             let l:filename = l:old_name
   10                 0.000097239             let l:item.filename = l:filename
                                  
   10                 0.000112368             if has_key(l:old_item, 'bufnr')
                                                  " If a buffer number is also given, include that too.
                                                  " If Vim detects that he buffer number is valid, it will
                                                  " be used instead of the filename.
                                                  let l:item.bufnr = l:old_item.bufnr
   10                 0.000104441             elseif has_key(l:bufnr_map, l:filename)
                                                  " Get the buffer number from the map, which can be faster.
    3                 0.000030002                 let l:item.bufnr = l:bufnr_map[l:filename]
    7                 0.000017625             else
                                                  " Look up the buffer number.
    7                 0.000565832                 let l:item.bufnr = bufnr(l:filename)
    7                 0.000084754                 let l:bufnr_map[l:filename] = l:item.bufnr
   10                 0.002860178             endif
                                          elseif has_key(l:old_item, 'bufnr')
                                              let l:item.bufnr = l:old_item.bufnr
   10                 0.000024226         endif
                                  
   10                 0.000108142         if has_key(l:old_item, 'detail')
    2                 0.000020601             let l:item.detail = l:old_item.detail
   10                 0.000023802         endif
                                  
                                          " Pass on a end_col key if set, used for highlights.
   10                 0.000087391         if has_key(l:old_item, 'end_col')
                                              let l:item.end_col = str2nr(l:old_item.end_col)
   10                 0.000045965         endif
                                  
   10                 0.000088904         if has_key(l:old_item, 'end_lnum')
                                              let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                  
                                              " When the error ends after the end of the file, put it at the
                                              " end. This is only done for the current buffer.
                                              if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                                  let l:item.end_lnum = l:last_line_number
                                              endif
   10                 0.000016526         endif
                                  
   10                 0.000086025         if has_key(l:old_item, 'sub_type')
                                              let l:item.sub_type = l:old_item.sub_type
   10                 0.000153306         endif
                                  
   10                 0.000070614         if l:item.lnum < 1
                                              " When errors appear before line 1, put them at line 1.
    4                 0.000035039             let l:item.lnum = 1
    6                 0.000059689         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                              " When errors go beyond the end of the file, put them at the end.
                                              " This is only done for the current buffer.
                                              let l:item.lnum = l:last_line_number
    6                 0.000061527         elseif get(l:old_item, 'vcol', 0)
                                              " Convert virtual column positions to byte positions.
                                              " The positions will be off if the buffer has changed recently.
                                              let l:line = getbufline(a:buffer, l:item.lnum)[0]
                                  
                                              let l:item.col = ale#util#Col(l:line, l:item.col)
                                  
                                              if has_key(l:item, 'end_col')
                                                  let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                                  
                                                  let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                              endif
   10                 0.000017039         endif
                                  
   10                 0.000139679         call add(l:new_loclist, l:item)
   13                 0.000079878     endfor
                                  
    3   0.000377502   0.000130631     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                                  
    3                 0.000035765     if !empty(l:type_map)
                                          call s:RemapItemTypes(l:type_map, l:new_loclist)
    3                 0.000009087     endif
                                  
    3                 0.000018589     return l:new_loclist

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 2 times
Total time:   0.002027385
 Self time:   0.001991059

count     total (s)      self (s)
    2                 0.000026564     if exists('t:NERDTreeBufName')
                                          return bufwinnr(t:NERDTreeBufName)
    2                 0.000005112     endif
                                  
                                      " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
    4                 0.001613884     for w in range(1,winnr('$'))
    2   0.000262560   0.000226234         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . 'win_\d\+$'
                                              return w
    2                 0.000006525         endif
    4                 0.000012775     endfor
                                  
    2                 0.000010175     return -1

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/plugged/ale/autoload/ale/highlight.vim:205
Called 3 times
Total time:   0.063884012
 Self time:   0.002018347

count     total (s)      self (s)
    3                 0.001619758     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                                  
                                      " Set the list in the buffer variable.
    3                 0.000132042     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                                  
    3   0.000284684   0.000077088     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                                  
    3                 0.000032815     if !empty(l:exclude_list)
                                          call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    3                 0.000008576     endif
                                  
                                      " Update highlights for the current buffer, which may or may not
                                      " be the buffer we just set highlights for.
    3   0.061731823   0.000073754     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:190
Called 3 times
Total time:   0.279875092
 Self time:   0.009588977

count     total (s)      self (s)
    3   0.000217158   0.000057701     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                                  
    3                 0.000019726     if g:ale_use_neovim_diagnostics_api
                                          call ale#engine#SendResultsToNeovimDiagnostics(a:buffer, a:loclist)
    3                 0.000008051     endif
                                  
                                      " Set signs first. This could potentially fix some line numbers.
                                      " The List could be sorted again here by SetSigns.
    3                 0.000021162     if !g:ale_use_neovim_diagnostics_api && g:ale_set_signs
    3   0.097517803   0.000151368         call ale#sign#SetSigns(a:buffer, a:loclist)
    3                 0.000008326     endif
                                  
    3                 0.000024301     if g:ale_set_quickfix || g:ale_set_loclist
    3   0.000584771   0.000102392         call ale#list#SetLists(a:buffer, a:loclist)
    3                 0.000006725     endif
                                  
    3                 0.000039063     if exists('*ale#statusline#Update')
                                          " Don't load/run if not already loaded.
                                          call ale#statusline#Update(a:buffer, a:loclist)
    3                 0.000007612     endif
                                  
    3                 0.000021951     if !g:ale_use_neovim_diagnostics_api && g:ale_set_highlights
    3   0.063958476   0.000074464         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    3                 0.000008963     endif
                                  
    3                 0.000053765     if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'all' || g:ale_virtualtext_cursor == 2)
    3   0.114211975   0.008240768         call ale#virtualtext#SetTexts(a:buffer, a:loclist)
    3                 0.000008338     endif
                                  
    3                 0.000017175     if l:linting_is_done
    1                 0.000004875         if g:ale_echo_cursor
                                              " Try and echo the warning now.
                                              " This will only do something meaningful if we're in normal mode.
    1   0.001848266   0.000030476             call ale#cursor#EchoCursorWarning()
    1                 0.000002462         endif
                                  
    1                 0.000013625         if !g:ale_use_neovim_diagnostics_api&& (g:ale_virtualtext_cursor is# 'current' || g:ale_virtualtext_cursor == 1)
                                              " Try and show the warning now.
                                              " This will only do something meaningful if we're in normal mode.
                                              call ale#virtualtext#ShowCursorWarning()
    1                 0.000002562         endif
                                  
                                          " Reset the save event marker, used for opening windows, etc.
    1                 0.000018988         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                          " Set a marker showing how many times a buffer has been checked.
    1                 0.000023351         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                                  
                                          " Automatically remove all managed temporary files and directories
                                          " now that all jobs have completed.
    1   0.000492692   0.000033525         call ale#command#RemoveManagedFiles(a:buffer)
                                  
                                          " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000349150   0.000203482         silent doautocmd <nomodeline> User ALELintPost
    3                 0.000007438     endif

FUNCTION  <SNR>114_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:196
Called 40 times
Total time:   0.289455693
 Self time:   0.021427453

count     total (s)      self (s)
   40                 0.000516761     if pumvisible()
                                        return
   40                 0.000084754     endif
   40                 0.000521082     let group = a:from.'_to_'.a:to.a:suffix
   40   0.057530326   0.000820346     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   40   0.079168101   0.000834699     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   40                 0.000236782     if a:inverse
   12                 0.000277034       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   28                 0.000556260     else
   28                 0.006758840       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   40                 0.000149703     endif
   40                 0.000503193     let a:dict[group] = colors
   40   0.140095440   0.007110582     call airline#highlighter#exec(group, colors)

FUNCTION  ale#statusline#Update()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:21
Called 1 time
Total time:   0.011501437
 Self time:   0.011473474

count     total (s)      self (s)
    1                 0.000020650     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                          return
    1                 0.000002101     endif
                                  
    1                 0.000135205     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    1   0.000057002   0.000029039     let l:count = s:CreateCountDict()
    1                 0.000015300     let l:count.total = len(l:loclist)
                                  
                                      " Allows easy access to the first instance of each problem type.
    1                 0.000008912     let l:first_problems = {}
                                  
   16                 0.000088416     for l:entry in l:loclist
   15                 0.000115641         if l:entry.type is# 'W'
   15                 0.000288386             if get(l:entry, 'sub_type', '') is# 'style'
                                                  let l:count.style_warning += 1
                                  
                                                  if l:count.style_warning == 1
                                                      let l:first_problems.style_warning = l:entry
                                                  endif
   15                 0.000025329             else
   15                 0.008544553                 let l:count.warning += 1
                                  
   15                 0.000188709                 if l:count.warning == 1
    1                 0.000009288                     let l:first_problems.warning = l:entry
   15                 0.000034864                 endif
   15                 0.000023910             endif
                                          elseif l:entry.type is# 'I'
                                              let l:count.info += 1
                                  
                                              if l:count.info == 1
                                                  let l:first_problems.info = l:entry
                                              endif
                                          elseif get(l:entry, 'sub_type', '') is# 'style'
                                              let l:count.style_error += 1
                                  
                                              if l:count.style_error == 1
                                                  let l:first_problems.style_error = l:entry
                                              endif
                                          else
                                              let l:count.error += 1
                                  
                                              if l:count.error == 1
                                                  let l:first_problems.error = l:entry
                                              endif
   15                 0.000021787         endif
   16                 0.000038378     endfor
                                  
                                      " Set keys for backwards compatibility.
    1                 0.000039963     let l:count[0] = l:count.error + l:count.style_error
    1                 0.000018651     let l:count[1] = l:count.total - l:count[0]
                                  
    1                 0.000018425     let g:ale_buffer_info[a:buffer].count = l:count
    1                 0.000013513     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  <SNR>147_fromEventSinkHandler()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:509
Called 8 times
Total time:   0.000113116
 Self time:   0.000113116

count     total (s)      self (s)
    8                 0.000093153     if a:t != 2 | return | endif
                                      let a:data['disposed'] = 1
                                      execute 'augroup ' a:data['augroup']
                                      autocmd!
                                      execute 'augroup end'
                                      if has_key(s:event_handlers_data, a:data['handler_index'])
                                          call remove(s:event_handlers_data, a:data['handler_index'])
                                      endif

FUNCTION  <SNR>147_mergeTalkbackCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:794
Called 4 times
Total time:   0.001043086
 Self time:   0.000929970

count     total (s)      self (s)
    4                 0.000056114     if a:t == 2 | let a:data['ended'] = 1 | endif
    4                 0.000045502     let l:i = 0
   12                 0.000143018     while l:i < a:data['n']
    8                 0.000186320         if l:i < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:i] != 0
    8   0.000337938   0.000224822             call a:data['sourceTalkbacks'][l:i](a:t, a:d)
    8                 0.000022313         endif
    8                 0.000065990         let l:i += 1
   12                 0.000044627     endwhile

FUNCTION  <SNR>147_distinctUntilChangedSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:982
Called 4 times
Total time:   0.001795452
 Self time:   0.000572973

count     total (s)      self (s)
    4                 0.000113716     if a:t == 0 | let a:data['talkback'] = a:d | endif
    4                 0.000061940     if a:t != 1
                                          call a:data['sink'](a:t, a:d)
                                          return
    4                 0.000007987     endif
                                  
    4   0.000256022   0.000138156     if a:data['inited'] && has_key(a:data, 'prev') && a:data['compare'](a:data['prev'], a:d)
    4   0.001244594   0.000139981         call a:data['talkback'](1, lsp#callbag#undefined())
    4                 0.000013875         return
                                      endif
                                  
                                      let a:data['inited'] = 1
                                      let a:data['prev'] = a:d
                                      call a:data['sink'](1, a:d)

FUNCTION  ale#history#Get()
    Defined: ~/.vim/plugged/ale/autoload/ale/history.vim:8
Called 6 times
Total time:   0.000232496
 Self time:   0.000232496

count     total (s)      self (s)
    6                 0.000215394     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>135_ExitCallback()
    Defined: ~/.vim/plugged/ale/autoload/ale/command.vim:285
Called 3 times
Total time:   0.405006845
 Self time:   0.001298592

count     total (s)      self (s)
    3                 0.000128304     if !has_key(s:buffer_data, a:buffer)
                                          return
    3                 0.000009275     endif
                                  
    3                 0.000058627     let l:jobs = s:buffer_data[a:buffer].jobs
                                  
    3                 0.000043952     if !has_key(l:jobs, a:data.job_id)
                                          return
    3                 0.000006275     endif
                                  
    3                 0.000052489     let l:job_type = remove(l:jobs, a:data.job_id)
                                  
    3                 0.000020501     if g:ale_history_enabled
    3   0.001546068   0.000088790         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                                  
                                          " Log the output of the command for ALEInfo if we should.
    3                 0.000032014         if g:ale_history_log_output && a:data.log_output is 1
    3   0.001159729   0.000118742             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    3                 0.000009325         endif
    3                 0.000004851     endif
                                  
                                      " If the callback starts any new jobs, use the same job type for them.
    3                 0.000055277     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    3   0.401026915   0.000171966     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                                  
    3                 0.000038013     let l:result = a:data.result
    3                 0.000040738     let l:result.value = l:value
                                  
                                      " Set the default cwd for this buffer in this call stack.
    3   0.000367589   0.000108617     call ale#command#SetCwd(a:buffer, l:result.cwd)
                                  
    3                 0.000011063     try
    3                 0.000053289         if get(l:result, 'result_callback', v:null) isnot v:null
                                              call call(l:result.result_callback, [l:value])
    3                 0.000007800         endif
    3                 0.000015002     finally
    3   0.000146955   0.000050888         call ale#command#ResetCwd(a:buffer)
    3                 0.000013500     endtry

FUNCTION  coc#compat#tabnr_id()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/compat.vim:71
Called 2 times
Total time:   0.000282624
 Self time:   0.000072154

count     total (s)      self (s)
    2                 0.000014613   if s:is_vim
    2   0.000261672   0.000051202     return coc#api#TabNrId(a:tabnr)
                                    endif
                                    return nvim_list_tabpages()[a:tabnr - 1]

FUNCTION  <SNR>147_filterSourceCallback()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/callbag.vim:447
Called 4 times
Total time:   0.002052350
 Self time:   0.001614957

count     total (s)      self (s)
    4                 0.001116814     if a:t == 0
                                          let a:data['talkback'] = a:d
                                          call a:data['sink'](a:t, a:d)
    4                 0.000035900     elseif a:t == 1
    4   0.000138617   0.000121153         if a:data['condition'](a:d)
    4   0.000534721   0.000114792             call a:data['sink'](a:t, a:d)
                                          else
                                              call a:data['talkback'](1, lsp#callbag#undefined())
    4                 0.000010562         endif
                                      else
                                          call a:data['sink'](a:t, a:d)
    4                 0.000009400     endif

FUNCTION  <SNR>214_BufferCacheExists()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim:88
Called 21 times
Total time:   0.000811593
 Self time:   0.000811593

count     total (s)      self (s)
   21                 0.000480840     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                          return 0
   21                 0.000050226     endif
                                  
   21                 0.000073341     return 1

FUNCTION  ale#path#IsTempName()
    Defined: ~/.vim/plugged/ale/autoload/ale/path.vim:161
Called 10 times
Total time:   0.005143883
 Self time:   0.003678419

count     total (s)      self (s)
   10   0.001664848   0.000199384     let l:filename = ale#path#Simplify(a:filename)
                                  
   10                 0.000540332     return l:filename[:len(s:temp_dir) - 1] is# s:temp_dir|| l:filename[:len(s:resolved_temp_dir) - 1] is# s:resolved_temp_dir

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:485
Called 1 time
Total time:   0.000997661
 Self time:   0.000115779

count     total (s)      self (s)
    1                 0.000019675     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1                 0.000014426     let l:loclist = get(l:info, 'loclist', [])
    1                 0.000013788     let l:pos = getpos('.')
    1   0.000922458   0.000040576     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    1                 0.000013775     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                                  
    1                 0.000008013     return [l:info, l:loc]

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:45
Called 9 times
Total time:   0.000154906
 Self time:   0.000154906

count     total (s)      self (s)
    9                 0.000134818   return get(b:, 'coc_current_function', '')

FUNCTION  <SNR>110_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:197
Called 5 times
Total time:   0.010815973
 Self time:   0.010815973

count     total (s)      self (s)
    5                 0.000097403   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    5                 0.000035075   if bidx_mode > 0
    5                 0.000025401     if bidx_mode == 1
   55                 0.000357648       for i in range(1, 10)
   50                 0.009400450         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
   55                 0.000207009       endfor
                                      else
                                        let start_idx = bidx_mode == 2 ? 11 : 1
                                        for i in range(start_idx, 99)
                                          exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                        endfor
    5                 0.000014900     endif
    5                 0.000186907     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    5                 0.000173370     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                      " Enable this for debugging
                                      " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    5                 0.000012664   endif

FUNCTION  ale#virtualtext#ShowMessage()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:157
Called 29 times
Total time:   0.085546235
 Self time:   0.037287719

count     total (s)      self (s)
   29                 0.000744689     if !s:has_virt_text || !bufexists(str2nr(a:buffer))
                                          return
   29                 0.000060404     endif
                                  
   29                 0.000513232     let l:line = max([1, a:item.lnum])
   29   0.009733061   0.004991769     let l:hl_group = ale#virtualtext#GetGroup(a:item)
                                  
                                      " Get a language-appropriate comment character, or default to '#'.
   29   0.004491506   0.001613179     let l:comment = ale#virtualtext#GetComment(a:buffer)
   29   0.004469228   0.000900723     let l:prefix = ale#Var(a:buffer, 'virtualtext_prefix')
   29   0.021767741   0.000695008     let l:prefix = ale#GetLocItemMessage(a:item, l:prefix)
   29                 0.004509353     let l:prefix = substitute(l:prefix, '\V%comment%', '\=l:comment', 'g')
   29                 0.002180077     let l:msg = l:prefix . substitute(a:item.text, '\n', ' ', 'g')
   29   0.016823763   0.000826104     let l:col_pad = ale#virtualtext#GetColumnPadding(a:buffer, l:line)
                                  
                                      " Store the last message we're going to set so we can read it in tests.
   29                 0.000259531     let s:last_message = l:msg
                                  
                                      " Discard virtualtext if padding is negative.
   29                 0.000182533     if l:col_pad < 0
                                          return
   29                 0.000054301     endif
                                  
   29                 0.003018963     if has('nvim')
                                          call nvim_buf_set_virtual_text(   a:buffer,   s:ns_id, l:line - 1,   [[l:msg, l:hl_group]],   {})
   29                 0.000187071     elseif s:emulate_virt
                                          let l:left_pad = col('$')
                                          call prop_add(l:line, l:left_pad, {'type': 'ale'})
                                          let s:last_virt = popup_create(l:msg, {   'line': -1,   'padding': [0, 0, 0, 1],   'mask': [[1, 1, 1, 1]],   'textprop': 'ale',   'highlight': l:hl_group,   'fixed': 1,   'wrap': 0,   'zindex': 2})
   29                 0.000087913     else
   29                 0.000595233         let l:type = prop_type_get(l:hl_group)
                                  
   29                 0.002305174         if l:type == {}
                                              call prop_type_add(l:hl_group, {'highlight': l:hl_group})
   29                 0.002916210         endif
                                  
                                          " Add highlight groups to the list so we can clear them later.
   29                 0.000595819         if index(s:hl_list, l:hl_group) == -1
                                              call add(s:hl_list, l:hl_group)
   29                 0.000084507         endif
                                  
                                          " We ignore all errors from prop_add.
   29                 0.003404970         silent! call prop_add(l:line, 0, {   'type': l:hl_group,   'text': ' ' . l:msg,   'bufnr': a:buffer,   'text_padding_left': l:col_pad,})
   29                 0.000393914     endif

FUNCTION  <SNR>181_err_cb()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/utils/job.vim:65
Called 1 time
Total time:   0.000479780
 Self time:   0.000117104

count     total (s)      self (s)
    1   0.000469692   0.000107016     call a:opts.on_stderr(a:jobid, a:data, 'stderr')

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:88
Called 32 times
Total time:   0.049511363
 Self time:   0.049511363

count     total (s)      self (s)
   32                 0.000434093     if type(a:string_or_ref) is v:t_string
    3                 0.000037739         return function(a:string_or_ref)
   29                 0.000102102     endif
                                  
   29                 0.043248897     return a:string_or_ref

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 9 times
Total time:   0.001493240
 Self time:   0.001493240

count     total (s)      self (s)
    9                 0.000300298   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
    9                 0.000148191     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
    9                 0.000156431     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
    9                 0.000132367     let default = get(g:, 'airline#extensions#keymap#default', '')
    9                 0.000063914     if (label !=# '')
    9                 0.000079428       let label .= ' '
    9                 0.000024014     endif
    9                 0.000089353     let keymap = &keymap
    9                 0.000106741     if has_key(short_codes, keymap)
                                        let keymap = short_codes[keymap]
    9                 0.000021153     endif
    9                 0.000226708     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                                    else
                                      return ''
                                    endif

FUNCTION  lsp#internal#diagnostics#state#_is_enabled_for_buffer()
    Defined: ~/.vim/plugged/vim-lsp/autoload/lsp/internal/diagnostics/state.vim:150
Called 27 times
Total time:   0.000589658
 Self time:   0.000589658

count     total (s)      self (s)
   27                 0.000516542     return getbufvar(a:bufnr, 'lsp_diagnostics_enabled', 1) == 1

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:109
Called 9 times
Total time:   0.019935315
 Self time:   0.006813521

count     total (s)      self (s)
    9                 0.000139691   if !get(w:, 'airline_active', 0)
                                      return ''
    9                 0.000020064   endif
                                    " Cache values, so that it isn't called too often
    9   0.005393794   0.000747292   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitsigns' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                      return b:airline_hunks
    9                 0.000020702   endif
    9   0.003772623   0.000215245   let hunks = airline#extensions#hunks#get_raw_hunks()
    9                 0.000059716   let string = ''
    9   0.000352899   0.000188456   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
    9                 0.000128853   if !empty(hunks)
                                      " hunks should contain [added, changed, deleted]
                                      for i in [0, 1, 2]
                                        if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                          let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                        endif
                                      endfor
    9                 0.000020050   endif
    9   0.000489107   0.000385341   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                      " branch extension not loaded, skip trailing whitespace
                                      let string = string[0:-2]
    9                 0.000044189   endif
                                  
    9                 0.000099479   let b:airline_hunks = string
    9                 0.000070251   let b:airline_changenr = b:changedtick
    9   0.004820698   0.000170993   let s:airline_winwidth = airline#util#winwidth()
    9                 0.000059578   return string

FUNCTION  coc#util#get_loaded_bufs()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:446
Called 2 times
Total time:   0.000350837
 Self time:   0.000350837

count     total (s)      self (s)
    2                 0.000342511   return map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]')

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:112
Called 9 times
Total time:   0.041342293
 Self time:   0.000261224

count     total (s)      self (s)
    9   0.041316115   0.000235046   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:531
Called 9 times
Total time:   0.000103766
 Self time:   0.000103766

count     total (s)      self (s)
    9                 0.000078241   return s:loaded_ext

FUNCTION  ale#virtualtext#GetComment()
    Defined: ~/.vim/plugged/ale/autoload/ale/virtualtext.vim:76
Called 29 times
Total time:   0.002878327
 Self time:   0.002878327

count     total (s)      self (s)
   29                 0.000733153     let l:filetype = getbufvar(a:buffer, '&filetype')
   29                 0.001206109     let l:split = split(getbufvar(a:buffer, '&commentstring'), '%s')
                                  
   29                 0.000790767     return !empty(l:split) ? trim(l:split[0]) : '#'

FUNCTIONS SORTED ON TOTAL TIME
count     total (s)      self (s)  function
    9   1.074110842   0.024987528  airline#check_mode()
    4   1.006533275   0.175542425  airline#highlighter#highlight()
  192   0.683395054   0.219972998  airline#highlighter#exec()
  272   0.487136684   0.164186148  airline#highlighter#get_highlight()
    3   0.417721464   0.005358929  <SNR>139_VimCloseCallback()
    3   0.412193229   0.000658725  <SNR>139_VimExitCallback()
    3   0.405006845   0.001298592  <SNR>135_ExitCallback()
    3   0.400854949   0.005190211  <SNR>134_HandleExit()
    3   0.387528295   0.000636422  <SNR>120_ApplyPartialTimer()
    3   0.386891873   0.009023250  <SNR>207_SetListsImpl()
    3   0.347128587   0.001856463  ale#engine#HandleLoclist()
 1088   0.315836124                <SNR>114_get_syn()
  260   0.315209298   0.299362719  ale#util#LocItemCompare()
    3   0.314850818   0.001724848  <SNR>207_Deduplicate()
  147   0.313125970   0.024096312  ale#util#LocItemCompareWithText()
   40   0.289455693   0.021427453  <SNR>114_exec_separator()
    3   0.279875092   0.009588977  ale#engine#SetResults()
   80   0.135043382   0.002328621  airline#themes#get_highlight()
    3   0.105971207   0.004420751  ale#virtualtext#SetTexts()
    3   0.097366435   0.002508817  ale#sign#SetSigns()

FUNCTIONS SORTED ON SELF TIME
count     total (s)      self (s)  function
 1088                 0.315836124  <SNR>114_get_syn()
  260   0.315209298   0.299362719  ale#util#LocItemCompare()
  192   0.683395054   0.219972998  airline#highlighter#exec()
    4   1.006533275   0.175542425  airline#highlighter#highlight()
  272   0.487136684   0.164186148  airline#highlighter#get_highlight()
   72                 0.076008126  airline#util#append()
   36                 0.060184306  <SNR>114_GetHiCmd()
   77                 0.052255390  ale#GetLocItemMessage()
   32                 0.049511363  ale#util#GetFunction()
  192                 0.037560325  <SNR>114_CheckDefined()
   29   0.085546235   0.037287719  ale#virtualtext#ShowMessage()
  142                 0.035772881  ale#util#GetItemPriority()
    3   0.062168487   0.030755384  <SNR>207_FixList()
   40                 0.030528058  <SNR>208_matchaddpos()
    3   0.048081209   0.028590460  ale#handlers#gcc#HandleGCCFormat()
    3   0.032971505   0.026733509  ale#engine#FixLocList()
    9   1.074110842   0.024987528  airline#check_mode()
    3   0.061658069   0.024159132  ale#highlight#UpdateHighlights()
  147   0.313125970   0.024096312  ale#util#LocItemCompareWithText()
    3                 0.022738713  <SNR>206_UpdateLineNumbers()

